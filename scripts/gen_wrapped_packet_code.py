#!/usr/bin/env python3

"""Simple script to generate skeleton packet code from command_name_map.json"""

from __future__ import annotations

from io import TextIO

from command_name_meta import *
from command_name_meta import CommandDescriptor, FieldDescriptor
from anthem_receiver.internal_types import *

import os
import sys
import csv
import logging

src_dir = os.path.dirname(os.path.abspath(__file__))

def snake_to_camel(s: str) -> str:
    return ''.join([w.capitalize() for w in s.split('_')])

def emit_field_declaration(f: TextIO, field: FieldDescriptor) -> None:
    field_type = field.field_type
    if field_type == "integer":
        f.write(f'''
    {field.name}: int = 0
    """{field.description}"""
''')

def em
def main() -> int:
    logging.basicConfig(level=logging.DEBUG)

    cmds_metadata = load_meta()

    cmds_by_name: Dict[str, CommandDescriptor] = cmds_metadata.cmds_by_name
    ir_sim_values = cmds_metadata.ir_sim_values

    # Generate the wrapped packet classes
    wrapped_packet_classes_py = os.path.join(src_dir, "wrapped_packet_classes.py")
    with open(wrapped_packet_classes_py, "w") as f:
        f.write(f'''# Copyright (c) 2023 Samuel J. McKelvie
#
# MIT License - See LICENSE file accompanying this package.
#

"""
Specific wrapped packet classes.

This file is auto-generated by scripts/gen_wrapped_packet_code.py. Do not edit.
"""

from __future__ import annotations

from anthem_reciver.internal_types import *
from anthem_receiver.protocol.wrapped_raw_packet import WrappedRawPacket, register_packet_class

''')
        by_class_name: Dict[str, CommandDescriptor] = {}
        for packet_meta in cmds_by_name.values():
            class_name = "Apkt" + snake_to_camel(packet_meta.name)
            by_class_name[class_name] = packet_meta

        for class_name in sorted(by_class_name.keys()):
            packet_meta = by_class_name[class_name]
            fields: List[FieldDescriptor] = packet_meta.fields
            packet_description = packet_meta.description.replace('\n', ' ')
            short_name: str
            long_name: str = packet_meta.name
            requires_zone: bool = False
            requires_tuner: bool = False
            requires_trigger: bool = False
            is_queryable: bool = False
            is_commandable: bool = True
            is_settable = packet_meta.is_settable
            is_reportable: bool = packet_meta.report
            is_error_response: bool = False

            pre_query_fields: List[FieldDescriptor] = []
            post_query_fields: List[FieldDescriptor] = []

            for field in fields:
                field_type = field.field_type
                if field_type == "zone":
                    requires_zone = True
                elif field_type == "tuner":
                    requires_tuner = True
                elif field_type == "trigger":
                    requires_trigger = True
                elif field_type == "query_placeholder":
                    is_queryable = True
                elif field_type == "command_code":
                    short_name = field.value
                else:
                    if is_queryable:
                        post_query_fields.append(field)
                    else:
                        pre_query_fields.append(field)
            if not is_queryable:
                post_query_fields = pre_query_fields
                pre_query_fields = []

            assert isinstance(short_name, str)




            f.write(f'''
@register_packet_class
class {class_name}(WrappedRawPacket):
    """
    Wrapped packet {long_name} ({short_name})

    {packet_description}
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "{packet_description}"
    """The description of the packet type, as a string."""

    short_name: str = "{short_name}"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "{long_name}"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = {requires_zone}
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = {requires_tuner}
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = {requires_trigger}
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = {is_queryable}
    """Whether this packet type is queryable"""

    is_commandable: bool = {is_commandable}
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = {is_reportable}
    """Whether changes to values associated with this packet type are asynchronously
       reported."""
''')

            if len(pre_query_fields) > 0:
                f.write(f'''
    # ============================================================
    # Pre-query parameters
''')
                for field in pre_query_fields:
                    emit_field_declaration(f, field)
            if len(post_query_fields) > 0:
                f.write(f'''
    # ============================================================
    # Post-query parameters
''')
                for field in post_query_fields:
                    emit_field_declaration(f, field)


    # Generate the IR codes enumumeration
    ir_codes_py = os.path.join(src_dir, "ir_codes.py")
    with open(ir_codes_py, "w") as f:
        f.write(f'''# Copyright (c) 2023 Samuel J. McKelvie
#
# MIT License - See LICENSE file accompanying this package.
#

"""
Enum of IR codes for Anthem receivers.

This file is auto-generated by scripts/gen_wrapped_packet_code.py. Do not edit.
"""

from __future__ import annotations

from enum import Enum

class IRCode(Enum):
''')
        for ir_code in sorted(ir_sim_values.keys()):
            v = ir_sim_values[ir_code]
            uc_name = v.name.upper()
            f.write(f'''    {uc_name:<20} = {ir_code:4}    # {v.description}\n''')

    return 0

if __name__ == "__main__":
    sys.exit(main())
