#!/usr/bin/env python3

"""Simple script to generate skeleton packet code from command_name_map.json"""

from __future__ import annotations

from io import TextIO

from command_name_meta import *
from command_name_meta import CommandDescriptor, FieldDescriptor
from anthem_receiver.internal_types import *

import os
import sys
import csv
import logging

src_dir = os.path.dirname(os.path.abspath(__file__))

def snake_to_camel(s: str) -> str:
    return ''.join([w.capitalize() for w in s.split('_')])

def emit_field_declaration(f: TextIO, field: FieldDescriptor, is_optional: bool=False) -> None:
    field_raw_type_name = field.field_type
    field_name = field.field_name
    field_type_name = field.user_type
    field_description = field.description
    field_converter = field.field_map_name
    if 'A' <= field_converter[0] <= 'Z':
        # a parameterized instance
        if not '(' in field_converter:
            if field_raw_type_name == "integer":
                field_converter = f"{field_converter}(min_length={field.min_length}, max_length={field.max_length}, min_value={field.min_value}, max_value={field.max_value}, require_sign={field.require_sign})"
            elif field_raw_type_name == "float":
                field_converter = f"{field_converter}(min_length={field.min_length}, max_length={field.max_length}, min_value={field.min_value}, max_value={field.max_value}, require_sign={field.require_sign}, digs_after_decimal={field.digs_after_decimal})"
            elif field_raw_type_name == "string":
                field_converter = f"{field_converter}(min_length={field.min_length}, max_length={field.max_length}, blank_pad={field.blank_pad}, null_pad={field.null_pad}, blank_strip={field.blank_strip}, null_strip={field.null_strip})"
            else:
                raise RuntimeError(f"Unable to initialize raw field type: {field_raw_type_name}")


    field_converter: Optional[str] = None
    field_converter_class_name: Optional[str] = None
    field_is_optional: bool = True
    field_default_value: str = "None"
    if field_mapper is None:
        if field_raw_type_name == "integer":
            field_type_name = "int"
        elif field_raw_type_name == "float":
            field_type_name = "float"
        elif field_raw_type_name == "string":
            field_type_name = "str"



    {field.name}: int = 0
    """{field_description}"""
''')

def main() -> int:
    logging.basicConfig(level=logging.DEBUG)

    cmds_metadata = load_meta()

    cmds_by_name: Dict[str, CommandDescriptor] = cmds_metadata.cmds_by_name
    ir_sim_values = cmds_metadata.ir_sim_values

    # Generate the wrapped packet classes
    wrapped_packet_classes_py = os.path.join(src_dir, "wrapped_packet_classes.py")
    with open(wrapped_packet_classes_py, "w") as f:
        f.write(f'''# Copyright (c) 2023 Samuel J. McKelvie
#
# MIT License - See LICENSE file accompanying this package.
#

"""
Specific wrapped packet classes.

This file is auto-generated by scripts/gen_wrapped_packet_code.py. Do not edit.
"""

from __future__ import annotations

from anthem_reciver.internal_types import *
from anthem_receiver.protocol.wrapped_raw_packet import WrappedRawPacket, register_packet_class

''')
        by_class_name: Dict[str, CommandDescriptor] = {}
        for packet_meta in cmds_by_name.values():
            class_name = "Apkt" + snake_to_camel(packet_meta.name)
            by_class_name[class_name] = packet_meta

        for class_name in sorted(by_class_name.keys()):
            packet_meta = by_class_name[class_name]
            fields: List[FieldDescriptor] = packet_meta.fields
            packet_description = packet_meta.description.replace('\n', ' ')
            short_name: str
            long_name: str = packet_meta.name
            requires_zone: bool = False
            requires_tuner: bool = False
            requires_trigger: bool = False
            is_queryable: bool = False
            is_commandable: bool = True
            is_settable = packet_meta.is_settable
            is_reportable: bool = packet_meta.report
            is_error_response: bool = False

            pre_query_fields: List[FieldDescriptor] = []
            post_query_fields: List[FieldDescriptor] = []

            for field in fields:
                field_type = field.field_type
                if field_type == "zone":
                    requires_zone = True
                elif field_type == "tuner":
                    requires_tuner = True
                elif field_type == "trigger":
                    requires_trigger = True
                elif field_type == "query_placeholder":
                    is_queryable = True
                elif field_type == "command_code":
                    short_name = field.value
                else:
                    if is_queryable:
                        post_query_fields.append(field)
                    else:
                        pre_query_fields.append(field)
            if not is_queryable:
                post_query_fields = pre_query_fields
                pre_query_fields = []

            assert isinstance(short_name, str)




            f.write(f'''
@register_packet_class
class {class_name}(WrappedRawPacket):
    """
    Wrapped packet {long_name} ({short_name})

    {packet_description}
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "{packet_description}"
    """The description of the packet type, as a string."""

    short_name: str = "{short_name}"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "{long_name}"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = {requires_zone}
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = {requires_tuner}
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = {requires_trigger}
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = {is_queryable}
    """Whether this packet type is queryable"""

    is_commandable: bool = {is_commandable}
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = {is_reportable}
    """Whether changes to values associated with this packet type are asynchronously
       reported."""
''')

            if len(pre_query_fields) > 0:
                f.write(f'''
    # ============================================================
    # Pre-query parameters
''')
                for field in pre_query_fields:
                    emit_field_declaration(f, field)
            if len(post_query_fields) > 0:
                f.write(f'''
    # ============================================================
    # Post-query parameters
''')
                for field in post_query_fields:
                    emit_field_declaration(f, field)


    # Generate the IR codes enumumeration
    ir_codes_py = os.path.join(src_dir, "ir_codes.py")
    with open(ir_codes_py, "w") as f:
        f.write(f'''# Copyright (c) 2023 Samuel J. McKelvie
#
# MIT License - See LICENSE file accompanying this package.
#

"""
Enum of IR codes for Anthem receivers.

This file is auto-generated by scripts/gen_wrapped_packet_code.py. Do not edit.
"""

from __future__ import annotations

from enum import Enum

class IRCode(Enum):
''')
        for ir_code in sorted(ir_sim_values.keys()):
            v = ir_sim_values[ir_code]
            uc_name = v.name.upper()
            f.write(f'''    {uc_name:<20} = {ir_code:4}    # {v.description}\n''')

    return 0

if __name__ == "__main__":
    sys.exit(main())
