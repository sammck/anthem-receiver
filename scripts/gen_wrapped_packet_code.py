#!/usr/bin/env python3

"""Simple script to generate skeleton packet code from command_name_map.json"""

from __future__ import annotations

from command_name_meta import *
from command_name_meta import CommandDescriptor, FieldDescriptor
from anthem_receiver.internal_types import *

import os
import sys
import csv
import logging

src_dir = os.path.dirname(os.path.abspath(__file__))

def gen_ircodes(ir_sim_values: Dict[int, IRSimValue]) -> None:
    # Generate the IR codes enumumeration
    ir_codes_py = os.path.join(src_dir, "ir_codes.py")
    with open(ir_codes_py, "w") as f:
        f.write(f'''# Copyright (c) 2023 Samuel J. McKelvie
#
# MIT License - See LICENSE file accompanying this package.
#

"""
Enum of IR codes for Anthem receivers.

This file is auto-generated by scripts/gen_wrapped_packet_code.py. Do not edit.
"""

from __future__ import annotations

from enum import Enum

class IRCode(Enum):
''')
        for ir_code in sorted(ir_sim_values.keys()):
            v = ir_sim_values[ir_code]
            uc_name = v.name.upper()
            f.write(f'''    {uc_name:<20} = {ir_code:4}    # {v.description}\n''')


def snake_to_camel(s: str) -> str:
    return ''.join([w.capitalize() for w in s.split('_')])

def get_field_converter_expr(field: FieldDescriptor) -> str:
    field_raw_type_name = field.field_type
    field_converter = field.value_map_name
    if 'A' <= field_converter[0] <= 'Z':
        # a parameterized instance
        if not '(' in field_converter:
            if field_raw_type_name == "integer":
                field_converter = f"{field_converter}(min_length={field.min_length}, max_length={field.max_length}, min_value={field.min_value}, max_value={field.max_value}, require_sign={field.require_sign})"
            elif field_raw_type_name == "float":
                field_converter = f"{field_converter}(min_length={field.min_length}, max_length={field.max_length}, min_value={field.min_value}, max_value={field.max_value}, require_sign={field.require_sign}, digs_after_decimal={field.digs_after_decimal})"
            elif field_raw_type_name == "string":
                field_converter = f"{field_converter}(min_length={field.min_length}, max_length={field.max_length}, blank_pad={field.blank_pad}, null_pad={field.null_pad}, rstrip={field.rstrip}, null_strip={field.null_rstrip})"
            else:
                raise RuntimeError(f"Unable to initialize raw field type: {field_raw_type_name}")
    return field_converter

def emit_field_declaration(f: TextIO, field: FieldDescriptor, is_optional: bool=False) -> None:
    field_name = field.field_name
    field_type_name = field.user_type
    field_description = field.description
    field_converter = get_field_converter_expr(field)

    field_declaration = f"{field_name}: {field_type_name}" if not is_optional else f"{field_name}: Optional[{field_type_name}] = None"

    f.write(f'''
    _{field_name}_converter = {field_converter}
    """Field converter for {field_name}"""

    {field_declaration}
    """{field_description}"""
''')

def get_field_constructor_param(field: FieldDescriptor, is_optional: bool=False) -> str:
    field_name = field.field_name
    field_type_name = field.user_type

    result = f"{field_name}: {field_type_name}" if not is_optional else f"{field_name}: Optional[{field_type_name}]=None"
    return result

def emit_field_constructor_init(f: TextIO, field: FieldDescriptor, is_optional: bool=False, indent: int=8) -> None:
    field_name = field.field_name

    f.write(' ' * indent + f'self.{field_name} = {field_name}\n')

def emit_field_parse(f: TextIO, field: FieldDescriptor, indent: int=8) -> None:
    field_name = field.field_name

    f.write(' ' * indent + f'self.{field_name}, raw_data = self._{field_name}_converter.parse_raw_data(raw_data)\n')

def emit_field_from_jsonable(f: TextIO, field: FieldDescriptor, is_optional: bool=False, indent: int=8) -> None:
    field_name = field.field_name

    fetch_expr = f"data[{field_name!r}]" if not is_optional else f"data.get({field_name!r}, None)"

    f.write(' ' * indent + f'self.{field_name} = self._{field_name}_converter.from_jsonable({fetch_expr})\n')

def emit_field_to_jsonable(f: TextIO, field: FieldDescriptor, is_optional: bool=False, indent: int=8) -> None:
    field_name = field.field_name
    if is_optional:
        f.write(' ' * indent + f'if self.{field_name} is not None:\n')
        indent += 4
    f.write(' ' * indent + f'data[{field_name!r}] = self._{field_name}_converter.to_jsonable(self.{field_name})\n')

def get_field_raw_data_expr(field: FieldDescriptor, is_optional: bool=False) -> str:
    field_name = field.field_name
    if is_optional:
        return f'self._{field_name}_converter.to_raw_data(self.{field_name}) if self.{field_name} is not None else b""'
    else:
        return f'self._{field_name}_converter.to_raw_data(self.{field_name})'

def emit_field_to_raw_data(f: TextIO, field: FieldDescriptor, is_optional: bool=False, indent: int=8) -> None:
    field_name = field.field_name

    expr = get_field_raw_data_expr(field, is_optional=is_optional)
    f.write(' ' * indent + f'raw_data += {expr}\n')

def emit_class_header(
        f: TextIO, class_name: str, packet_description: str, long_name: str,
        short_name: str, requires_zone: bool, requires_tuner: bool,
        requires_trigger: bool,
        is_queryable: bool,
        is_commandable: bool,
        is_reportable: bool,
      ) -> None:
    f.write(f'''
@register_packet_class
class {class_name}(WrappedRawPacket):
    """
    Wrapped packet {long_name} ({short_name})

    {packet_description}
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "{packet_description}"
    """The description of the packet type, as a string."""

    short_name: str = "{short_name}"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "{long_name}"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = {requires_zone}
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = {requires_tuner}
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = {requires_trigger}
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = {is_queryable}
    """Whether this packet type is queryable"""

    is_commandable: bool = {is_commandable}
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = {is_reportable}
    """Whether changes to values associated with this packet type are asynchronously
       reported."""
''')

def emit_field_declarations(f: TextIO, pre_query_fields: List[FieldDescriptor], post_query_fields: List[FieldDescriptor]) -> None:
    if len(pre_query_fields) > 0:
        f.write(f'''
    # ============================================================
    # Pre-query parameters
''')
        for field in pre_query_fields:
            emit_field_declaration(f, field, is_optional=False)

    if len(post_query_fields) > 0:
        f.write(f'''
    # ============================================================
    # Post-query parameters
''')
        for field in post_query_fields:
            emit_field_declaration(f, field, is_optional=True)

def emit_constructor(f: TextIO, pre_query_fields: List[FieldDescriptor], post_query_fields: List[FieldDescriptor]) -> None:
    f.write(f'\n    def __init__(\n            self,\n')
    if len(pre_query_fields) > 0:
        for field in pre_query_fields:
            cp = get_field_constructor_param(field, is_optional=False)
            f.write(f'            {cp},\n')
    if len(post_query_fields) > 0:
        for field in post_query_fields:
            cp = get_field_constructor_param(field, is_optional=True)
            f.write(f'            {cp},\n')
    f.write('          ):\n        super().__init__()\n')
    for field in pre_query_fields:
        emit_field_constructor_init(f, field, is_optional=False)
    for field in post_query_fields:
        emit_field_constructor_init(f, field, is_optional=True)

def emit_pre_query_from_jsonable(f: TextIO, pre_query_fields: List[FieldDescriptor]) -> None:
    f.write(f'\n    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:\n')
    if len(pre_query_fields) == 0:
        f.write('        return\n')
    else:
        for field in pre_query_fields:
            emit_field_from_jsonable(f, field, is_optional=False)

def emit_post_query_from_jsonable(f: TextIO, post_query_fields: List[FieldDescriptor]) -> None:
    f.write(f'''
    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
''')
    if len(post_query_fields) == 0:
        f.write('        return\n')
    else:
        for field in post_query_fields:
            emit_field_from_jsonable(f, field, is_optional=True)

def emit_parse_pre_query(f: TextIO, pre_query_fields: List[FieldDescriptor]) -> None:
    f.write('\n    def parse_pre_query(self, raw_data: bytes) -> bytes:\n')
    for field in pre_query_fields:
        emit_field_parse(f, field)
    f.write('        return raw_data\n')

def emit_parse_post_query(f: TextIO, post_query_fields: List[FieldDescriptor]) -> None:
    f.write('\n    def parse_post_query(self, raw_data: bytes) -> bytes:\n')
    for field in post_query_fields:
        emit_field_parse(f, field)
    f.write('        return raw_data\n')

def emit_pre_query_to_jsonable(f: TextIO, pre_query_fields: List[FieldDescriptor]) -> None:
    f.write('\n    def pre_query_to_jsonable(self, data: JsonableDict) -> None:\n')
    if len(pre_query_fields) == 0:
        f.write('        return\n')
    else:
        for field in pre_query_fields:
            emit_field_to_jsonable(f, field, is_optional=False)

def emit_post_query_to_jsonable(f: TextIO, post_query_fields: List[FieldDescriptor]) -> None:
    f.write('\n    def post_query_to_jsonable(self, data: JsonableDict) -> None:\n')
    if len(post_query_fields) == 0:
        f.write('        return\n')
    else:
        for field in post_query_fields:
            emit_field_to_jsonable(f, field, is_optional=True)

def emit_pre_query_to_raw_data(f: TextIO, pre_query_fields: List[FieldDescriptor]) -> None:
    f.write('\n    def pre_query_to_raw_data(self) -> bytes:\n        raw_data = b""\n')

    for field in pre_query_fields:
        emit_field_to_raw_data(f, field, is_optional=False)
    f.write('        return raw_data\n')

def emit_post_query_to_raw_data(f: TextIO, post_query_fields: List[FieldDescriptor]) -> None:
    f.write('\n    def post_query_to_raw_data(self) -> bytes:\n        raw_data = b""\n')

    for field in post_query_fields:
        emit_field_to_raw_data(f, field, is_optional=True)
    f.write('        return raw_data\n')

def emit_wrapped_class_file_header(f: TextIO) -> None:
    f.write(f'''# Copyright (c) 2023 Samuel J. McKelvie
#
# MIT License - See LICENSE file accompanying this package.
#

"""
Specific wrapped packet classes.

This file is auto-generated by scripts/gen_wrapped_packet_code.py. Do not edit.
"""

from __future__ import annotations

from anthem_receiver.internal_types import *
from anthem_receiver.protocol.wrapped_raw_packet import (
    WrappedRawPacket,
    register_packet_class,
    bool_field_converter,
    IntFieldConverter,
    StrFieldConverter,
    FloatFieldConverter,
    audio_channels_status_field_converter,
    AudioChannelsStatus,
    audio_format_field_converter,
    AudioFormat,
    audio_listening_mode_field_converter,
    AudioListeningMode,
    audio_channel_group_field_converter,
    AudioChannelGroup,
    dolby_dynamic_range_field_converter,
    DolbyDynamicRange,
    front_panel_brightness_field_converter,
    on_off_toggle_field_converter,
    OnOffToggle,
    eq_band_field_converter,
    EqBand,
    video_resolution_field_converter,
    VideoResolution,
    tuner_status_field_converter,
    TunerStatus,
  )

from anthem_receiver.protocol.ir_codes import IRCode, IRCodeValue, ir_code_field_converter

''')

def gen_wrapped_packet_code(cmds_by_name: Dict[str, CommandDescriptor]) -> None:
    # Generate the wrapped packet classes
    wrapped_packet_classes_py = os.path.join(src_dir, "wrapped_packet_classes.py")
    with open(wrapped_packet_classes_py, "w") as f:
        emit_wrapped_class_file_header(f)
        by_class_name: Dict[str, CommandDescriptor] = {}
        for packet_meta in cmds_by_name.values():
            class_name = "Apkt" + snake_to_camel(packet_meta.name)
            by_class_name[class_name] = packet_meta

        for class_name in sorted(by_class_name.keys()):
            packet_meta = by_class_name[class_name]
            fields: List[FieldDescriptor] = packet_meta.fields
            packet_description = packet_meta.description.replace('\n', ' ')
            short_name: str
            long_name: str = packet_meta.name
            requires_zone: bool = False
            requires_tuner: bool = False
            requires_trigger: bool = False
            is_queryable: bool = False
            is_commandable: bool = True
            # is_settable = packet_meta.is_settable
            is_reportable: bool = packet_meta.report
            # is_error_response: bool = False

            pre_query_fields: List[FieldDescriptor] = []
            post_query_fields: List[FieldDescriptor] = []

            for field in fields:
                field_type = field.field_type
                if field_type == "zone_prefix":
                    requires_zone = True
                elif field_type == "tuner_prefix":
                    requires_tuner = True
                elif field_type == "trigger_prefix":
                    requires_trigger = True
                elif field_type == "query_placeholder":
                    is_queryable = True
                elif field_type == "command_code":
                    short_name = field.value
                else:
                    if is_queryable:
                        post_query_fields.append(field)
                    else:
                        pre_query_fields.append(field)

            assert isinstance(short_name, str)

            emit_class_header(f, class_name,
                    packet_description=packet_description,
                    long_name=long_name,
                    short_name=short_name,
                    requires_zone=requires_zone,
                    requires_tuner=requires_tuner,
                    requires_trigger=requires_trigger,
                    is_queryable=is_queryable,
                    is_commandable=is_commandable,
                    is_reportable=is_reportable,
                )

            emit_field_declarations(f, pre_query_fields, post_query_fields)
            emit_constructor(f, pre_query_fields, post_query_fields)
            emit_pre_query_from_jsonable(f, pre_query_fields)
            emit_post_query_from_jsonable(f, post_query_fields)
            emit_parse_pre_query(f, pre_query_fields)
            emit_parse_post_query(f, post_query_fields)
            emit_pre_query_to_jsonable(f, pre_query_fields)
            emit_post_query_to_jsonable(f, post_query_fields)
            emit_pre_query_to_raw_data(f, pre_query_fields)
            emit_post_query_to_raw_data(f, post_query_fields)






def main() -> int:
    logging.basicConfig(level=logging.DEBUG)

    cmds_metadata = load_meta()

    cmds_by_name: Dict[str, CommandDescriptor] = cmds_metadata.cmds_by_name
    ir_sim_values = cmds_metadata.ir_sim_values

    gen_wrapped_packet_code(cmds_by_name)
    gen_ircodes(ir_sim_values)

    return 0

if __name__ == "__main__":
    sys.exit(main())
