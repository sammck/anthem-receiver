# Copyright (c) 2023 Samuel J. McKelvie
#
# MIT License - See LICENSE file accompanying this package.
#

"""
Specific wrapped packet classes.

This file is auto-generated by scripts/gen_wrapped_packet_code.py. Do not edit.
"""

from __future__ import annotations

from anthem_receiver.internal_types import *
from anthem_receiver.protocol.wrapped_raw_packet import (
    WrappedRawPacket,
    register_packet_class,
    bool_field_converter,
    IntFieldConverter,
    StrFieldConverter,
    FloatFieldConverter,
    audio_channels_status_field_converter,
    AudioChannelsStatus,
    audio_format_field_converter,
    AudioFormat,
    audio_listening_mode_field_converter,
    AudioListeningMode,
    audio_channel_group_field_converter,
    AudioChannelGroup,
    dolby_dynamic_range_field_converter,
    DolbyDynamicRange,
    front_panel_brightness_field_converter,
    on_off_toggle_field_converter,
    OnOffToggle,
    eq_band_field_converter,
    EqBand,
    video_resolution_field_converter,
    VideoResolution,
    tuner_status_field_converter,
    TunerStatus,
  )

from anthem_receiver.protocol.ir_codes import IRCode, IRCodeValue, ir_code_field_converter


@register_packet_class
class ApktArcEnable(WrappedRawPacket):
    """
    Wrapped packet arc_enable (ARC)

    Turn ARC (Anthem Room Correction) off (y=0) or on (y=1) for the specified zone (currently ARC is only available on the Main zone, x=1)
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Turn ARC (Anthem Room Correction) off (y=0) or on (y=1) for the specified zone (currently ARC is only available on the Main zone, x=1)"
    """The description of the packet type, as a string."""

    short_name: str = "ARC"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "arc_enable"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _enable_converter = bool_field_converter
    """Field converter for enable"""

    enable: Optional[bool] = None
    """ARC off (y=0) or on (y=1)"""

    def __init__(
            self,
            enable: Optional[bool]=None,
          ):
        super().__init__()
        self.enable = enable

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.enable = self._enable_converter.from_jsonable(data.get('enable', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.enable, raw_data = self._enable_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.enable is not None:
            data['enable'] = self._enable_converter.to_jsonable(self.enable)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._enable_converter.to_raw_data(self.enable) if self.enable is not None else b""
        return raw_data

@register_packet_class
class ApktAudioInputBitRate(WrappedRawPacket):
    """
    Wrapped packet audio_input_bit_rate (BRT)

    Query audio input bit rate (kbps). For Analog/PCM inputs this is equal to the sample rate multiplied by the bit depth and the number of channels. returns Z1BRTxxxx, 0=analog
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query audio input bit rate (kbps). For Analog/PCM inputs this is equal to the sample rate multiplied by the bit depth and the number of channels. returns Z1BRTxxxx, 0=analog"
    """The description of the packet type, as a string."""

    short_name: str = "BRT"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "audio_input_bit_rate"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _bit_rate_kbps_converter = IntFieldConverter(min_length=1, max_length=4, min_value=0, max_value=9999, require_sign=False)
    """Field converter for bit_rate_kbps"""

    bit_rate_kbps: Optional[int] = None
    """Audio input bit rate (kbps).  0=analog"""

    def __init__(
            self,
            bit_rate_kbps: Optional[int]=None,
          ):
        super().__init__()
        self.bit_rate_kbps = bit_rate_kbps

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.bit_rate_kbps = self._bit_rate_kbps_converter.from_jsonable(data.get('bit_rate_kbps', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.bit_rate_kbps, raw_data = self._bit_rate_kbps_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.bit_rate_kbps is not None:
            data['bit_rate_kbps'] = self._bit_rate_kbps_converter.to_jsonable(self.bit_rate_kbps)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._bit_rate_kbps_converter.to_raw_data(self.bit_rate_kbps) if self.bit_rate_kbps is not None else b""
        return raw_data

@register_packet_class
class ApktAudioInputChannels(WrappedRawPacket):
    """
    Wrapped packet audio_input_channels (AIC)

    Query audio input channels: 0=no input, 1=other, 2=mono (center channel only), 3=2-channel, 4=5.1-channel, 5=6.1-channel, 6=7.1-channel, 7=Atmos. returns Z1AICx
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query audio input channels: 0=no input, 1=other, 2=mono (center channel only), 3=2-channel, 4=5.1-channel, 5=6.1-channel, 6=7.1-channel, 7=Atmos. returns Z1AICx"
    """The description of the packet type, as a string."""

    short_name: str = "AIC"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "audio_input_channels"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _status_converter = audio_channels_status_field_converter
    """Field converter for status"""

    status: Optional[AudioChannelsStatus] = None
    """0=no input, 1=other, 2=mono (center channel only), 3=2-channel, 4=5.1-channel, 5=6.1-channel, 6=7.1-channel, 7=Atmos"""

    def __init__(
            self,
            status: Optional[AudioChannelsStatus]=None,
          ):
        super().__init__()
        self.status = status

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.status = self._status_converter.from_jsonable(data.get('status', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.status, raw_data = self._status_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.status is not None:
            data['status'] = self._status_converter.to_jsonable(self.status)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._status_converter.to_raw_data(self.status) if self.status is not None else b""
        return raw_data

@register_packet_class
class ApktAudioInputFormat(WrappedRawPacket):
    """
    Wrapped packet audio_input_format (AIF)

    Query audio input format: 0=no input, 1=Analog, 2=PCM, 3=Dolby, 4= DSD, 5=DTS, 6=Atmos. Not all models support all formats (ex: DSD).. Returns Z1AIFxx
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query audio input format: 0=no input, 1=Analog, 2=PCM, 3=Dolby, 4= DSD, 5=DTS, 6=Atmos. Not all models support all formats (ex: DSD).. Returns Z1AIFxx"
    """The description of the packet type, as a string."""

    short_name: str = "AIF"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "audio_input_format"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _audio_format_converter = audio_format_field_converter
    """Field converter for audio_format"""

    audio_format: Optional[AudioFormat] = None
    """0=no input, 1=Analog, 2=PCM, 3=Dolby, 4= DSD, 5=DTS, 6=Atmos"""

    def __init__(
            self,
            audio_format: Optional[AudioFormat]=None,
          ):
        super().__init__()
        self.audio_format = audio_format

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.audio_format = self._audio_format_converter.from_jsonable(data.get('audio_format', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.audio_format, raw_data = self._audio_format_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.audio_format is not None:
            data['audio_format'] = self._audio_format_converter.to_jsonable(self.audio_format)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._audio_format_converter.to_raw_data(self.audio_format) if self.audio_format is not None else b""
        return raw_data

@register_packet_class
class ApktAudioInputName(WrappedRawPacket):
    """
    Wrapped packet audio_input_name (AIN)

    Query the current audio input name (maximum of 16 characters returned). Returns Z1AINx. Ex: Current audio input format is DTS Master Audio. 'Z1AIN?' Returns 'Z1AINDTS Master Audio'
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query the current audio input name (maximum of 16 characters returned). Returns Z1AINx. Ex: Current audio input format is DTS Master Audio. 'Z1AIN?' Returns 'Z1AINDTS Master Audio'"
    """The description of the packet type, as a string."""

    short_name: str = "AIN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "audio_input_name"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _input_name_converter = StrFieldConverter(min_length=1, max_length=16, blank_pad=False, null_pad=False, rstrip=True, null_strip=True)
    """Field converter for input_name"""

    input_name: Optional[str] = None
    """Audio input name"""

    def __init__(
            self,
            input_name: Optional[str]=None,
          ):
        super().__init__()
        self.input_name = input_name

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.input_name = self._input_name_converter.from_jsonable(data.get('input_name', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.input_name, raw_data = self._input_name_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.input_name is not None:
            data['input_name'] = self._input_name_converter.to_jsonable(self.input_name)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._input_name_converter.to_raw_data(self.input_name) if self.input_name is not None else b""
        return raw_data

@register_packet_class
class ApktAudioInputRateName(WrappedRawPacket):
    """
    Wrapped packet audio_input_rate_name (AIR)

    Query the current audio input rate name (maximum of 16 characters returned).. Returns Z1AIRx. For lossy input formats, returns the bit rate (ex 'Z1AIR384 kbps'). For lossless audio, analog audio, or PCM audio inputs it returns the sample rate (ex: Z1AIR48 kHz).
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query the current audio input rate name (maximum of 16 characters returned).. Returns Z1AIRx. For lossy input formats, returns the bit rate (ex 'Z1AIR384 kbps'). For lossless audio, analog audio, or PCM audio inputs it returns the sample rate (ex: Z1AIR48 kHz)."
    """The description of the packet type, as a string."""

    short_name: str = "AIR"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "audio_input_rate_name"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _input_rate_name_converter = StrFieldConverter(min_length=1, max_length=16, blank_pad=False, null_pad=False, rstrip=True, null_strip=True)
    """Field converter for input_rate_name"""

    input_rate_name: Optional[str] = None
    """Audio input rate name"""

    def __init__(
            self,
            input_rate_name: Optional[str]=None,
          ):
        super().__init__()
        self.input_rate_name = input_rate_name

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.input_rate_name = self._input_rate_name_converter.from_jsonable(data.get('input_rate_name', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.input_rate_name, raw_data = self._input_rate_name_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.input_rate_name is not None:
            data['input_rate_name'] = self._input_rate_name_converter.to_jsonable(self.input_rate_name)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._input_rate_name_converter.to_raw_data(self.input_rate_name) if self.input_rate_name is not None else b""
        return raw_data

@register_packet_class
class ApktAudioInputSamplingRate(WrappedRawPacket):
    """
    Wrapped packet audio_input_sampling_rate (SRT)

    Query audio input sampling rate (kHz). returns Z1SRTxxx, 0=analog direct
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query audio input sampling rate (kHz). returns Z1SRTxxx, 0=analog direct"
    """The description of the packet type, as a string."""

    short_name: str = "SRT"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "audio_input_sampling_rate"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _sampling_rate_khz_converter = IntFieldConverter(min_length=1, max_length=3, min_value=0, max_value=999, require_sign=False)
    """Field converter for sampling_rate_khz"""

    sampling_rate_khz: Optional[int] = None
    """Audio input sampling rate (kHz).  0=analog direct"""

    def __init__(
            self,
            sampling_rate_khz: Optional[int]=None,
          ):
        super().__init__()
        self.sampling_rate_khz = sampling_rate_khz

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.sampling_rate_khz = self._sampling_rate_khz_converter.from_jsonable(data.get('sampling_rate_khz', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.sampling_rate_khz, raw_data = self._sampling_rate_khz_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.sampling_rate_khz is not None:
            data['sampling_rate_khz'] = self._sampling_rate_khz_converter.to_jsonable(self.sampling_rate_khz)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._sampling_rate_khz_converter.to_raw_data(self.sampling_rate_khz) if self.sampling_rate_khz is not None else b""
        return raw_data

@register_packet_class
class ApktAudioListeningMode(WrappedRawPacket):
    """
    Wrapped packet audio_listening_mode (ALM)

    Audio Listening Mode: 00=None, 01=AnthemLogic-Movie, 02=AnthemLogic-Music, 03=PLIIx Movie, 04=PLIIx Music, 05=Neo:6 Cinema, 06=Neo:6 Music, 07=All Channel Stereo*, 08=All-Channel Mono*, 09=Mono*, 10=Mono-Academy*, 11=Mono(L)*, 12=Mono(R)*, 13=High Blend*, 14=Dolby Surround, 15=Neo:X-Cinema, 16=Neo:X-Music, na=cycle to next applicable, pa=cycle to previous applicable.  *Applicable to 2-channel source only. Some options are not available in all models or under all circumstances.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Audio Listening Mode: 00=None, 01=AnthemLogic-Movie, 02=AnthemLogic-Music, 03=PLIIx Movie, 04=PLIIx Music, 05=Neo:6 Cinema, 06=Neo:6 Music, 07=All Channel Stereo*, 08=All-Channel Mono*, 09=Mono*, 10=Mono-Academy*, 11=Mono(L)*, 12=Mono(R)*, 13=High Blend*, 14=Dolby Surround, 15=Neo:X-Cinema, 16=Neo:X-Music, na=cycle to next applicable, pa=cycle to previous applicable.  *Applicable to 2-channel source only. Some options are not available in all models or under all circumstances."
    """The description of the packet type, as a string."""

    short_name: str = "ALM"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "audio_listening_mode"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _listening_mode_converter = audio_listening_mode_field_converter
    """Field converter for listening_mode"""

    listening_mode: Optional[AudioListeningMode] = None
    """00=None, 01=AnthemLogic-Movie, 02=AnthemLogic-Music, 03=PLIIx Movie, 04=PLIIx Music, 05=Neo:6 Cinema, 06=Neo:6 Music, 07=All Channel Stereo*, 08=All-Channel Mono*, 09=Mono*, 10=Mono-Academy*, 11=Mono(L)*, 12=Mono(R)*, 13=High Blend*, 14=Dolby Surround, 15=Neo:X-Cinema, 16=Neo:X-Music, na=cycle to next applicable, pa=cycle to previous applicable"""

    def __init__(
            self,
            listening_mode: Optional[AudioListeningMode]=None,
          ):
        super().__init__()
        self.listening_mode = listening_mode

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.listening_mode = self._listening_mode_converter.from_jsonable(data.get('listening_mode', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.listening_mode, raw_data = self._listening_mode_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.listening_mode is not None:
            data['listening_mode'] = self._listening_mode_converter.to_jsonable(self.listening_mode)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._listening_mode_converter.to_raw_data(self.listening_mode) if self.listening_mode is not None else b""
        return raw_data

@register_packet_class
class ApktBalance(WrappedRawPacket):
    """
    Wrapped packet balance (BAL)

    Balance setting: yyy=% 0 to 100. Example: Z1BAL100 represents balance completely to the right. Z1BAL0 represents balance completely to the left. Z1BAL50 is balance in the middle. Entry is rounded to nearest valid value.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Balance setting: yyy=% 0 to 100. Example: Z1BAL100 represents balance completely to the right. Z1BAL0 represents balance completely to the left. Z1BAL50 is balance in the middle. Entry is rounded to nearest valid value."
    """The description of the packet type, as a string."""

    short_name: str = "BAL"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "balance"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _balance_percent_from_left_converter = IntFieldConverter(min_length=1, max_length=3, min_value=0, max_value=100, require_sign=False)
    """Field converter for balance_percent_from_left"""

    balance_percent_from_left: Optional[int] = None
    """Balance setting (0-100). 0=left, 100=right, 50=middle"""

    def __init__(
            self,
            balance_percent_from_left: Optional[int]=None,
          ):
        super().__init__()
        self.balance_percent_from_left = balance_percent_from_left

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.balance_percent_from_left = self._balance_percent_from_left_converter.from_jsonable(data.get('balance_percent_from_left', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.balance_percent_from_left, raw_data = self._balance_percent_from_left_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.balance_percent_from_left is not None:
            data['balance_percent_from_left'] = self._balance_percent_from_left_converter.to_jsonable(self.balance_percent_from_left)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._balance_percent_from_left_converter.to_raw_data(self.balance_percent_from_left) if self.balance_percent_from_left is not None else b""
        return raw_data

@register_packet_class
class ApktBalanceLeft(WrappedRawPacket):
    """
    Wrapped packet balance_left (BLT)

    Balance all channels to left: y= %: 0 to 100, m=minimum according to model. Entry is rounded to nearest valid value.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Balance all channels to left: y= %: 0 to 100, m=minimum according to model. Entry is rounded to nearest valid value."
    """The description of the packet type, as a string."""

    short_name: str = "BLT"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "balance_left"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _step_percent_converter = IntFieldConverter(min_length=1, max_length=3, min_value=0, max_value=100, require_sign=False)
    """Field converter for step_percent"""

    step_percent: int
    """Percent to balance to left (0-100)"""

    def __init__(
            self,
            step_percent: int,
          ):
        super().__init__()
        self.step_percent = step_percent

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.step_percent = self._step_percent_converter.from_jsonable(data['step_percent'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.step_percent, raw_data = self._step_percent_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['step_percent'] = self._step_percent_converter.to_jsonable(self.step_percent)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._step_percent_converter.to_raw_data(self.step_percent)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktBalanceRight(WrappedRawPacket):
    """
    Wrapped packet balance_right (BRT)

    Balance all channels to right: y= %: 0 to 100, m=minimum according to model. Entry is rounded to nearest valid value.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Balance all channels to right: y= %: 0 to 100, m=minimum according to model. Entry is rounded to nearest valid value."
    """The description of the packet type, as a string."""

    short_name: str = "BRT"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "balance_right"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _step_percent_converter = IntFieldConverter(min_length=1, max_length=3, min_value=0, max_value=100, require_sign=False)
    """Field converter for step_percent"""

    step_percent: int
    """Percent to balance to right (0-100)"""

    def __init__(
            self,
            step_percent: int,
          ):
        super().__init__()
        self.step_percent = step_percent

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.step_percent = self._step_percent_converter.from_jsonable(data['step_percent'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.step_percent, raw_data = self._step_percent_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['step_percent'] = self._step_percent_converter.to_jsonable(self.step_percent)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._step_percent_converter.to_raw_data(self.step_percent)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktChannelLevel(WrappedRawPacket):
    """
    Wrapped packet channel_level (LEV)

    Level setting: y=Channels: 0=subs, 1=fronts, 2=center, 3=surrounds, 4=backs, 5=LFE, 6=Heights1, 7=Heights2. s=sign: +/-, zz=value.  Example: Z1LEV1+01 represents fronts boosted by 1 dB.  Entry is rounded to nearest valid value. Subs, fronts, center, surrounds, backs have range -10 dB to +10 dB. LFE has range -10 dB to 0 dB.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Level setting: y=Channels: 0=subs, 1=fronts, 2=center, 3=surrounds, 4=backs, 5=LFE, 6=Heights1, 7=Heights2. s=sign: +/-, zz=value.  Example: Z1LEV1+01 represents fronts boosted by 1 dB.  Entry is rounded to nearest valid value. Subs, fronts, center, surrounds, backs have range -10 dB to +10 dB. LFE has range -10 dB to 0 dB."
    """The description of the packet type, as a string."""

    short_name: str = "LEV"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "channel_level"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _channel_group_converter = audio_channel_group_field_converter
    """Field converter for channel_group"""

    channel_group: AudioChannelGroup
    """channels: 0=subs, 1=fronts, 2=center, 3=surrounds, 4=backs, 5=LFE, 6=Heights1, 7=Heights2"""

    # ============================================================
    # Post-query parameters

    _level_db_converter = IntFieldConverter(min_length=1, max_length=3, min_value=-10, max_value=10, require_sign=False)
    """Field converter for level_db"""

    level_db: Optional[int] = None
    """Level setting value in dB"""

    def __init__(
            self,
            channel_group: AudioChannelGroup,
            level_db: Optional[int]=None,
          ):
        super().__init__()
        self.channel_group = channel_group
        self.level_db = level_db

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.channel_group = self._channel_group_converter.from_jsonable(data['channel_group'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.level_db = self._level_db_converter.from_jsonable(data.get('level_db', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.channel_group, raw_data = self._channel_group_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.level_db, raw_data = self._level_db_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['channel_group'] = self._channel_group_converter.to_jsonable(self.channel_group)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.level_db is not None:
            data['level_db'] = self._level_db_converter.to_jsonable(self.level_db)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._channel_group_converter.to_raw_data(self.channel_group)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._level_db_converter.to_raw_data(self.level_db) if self.level_db is not None else b""
        return raw_data

@register_packet_class
class ApktChannelLevelDown(WrappedRawPacket):
    """
    Wrapped packet channel_level_down (LDN)

    Level down: y=channels: 0=subs, 1=fronts, 2=center, 3=surrounds, 4=backs, 5=LFE, 6=Heights1, 7=Heights2. y=dB step: 0 to 10, m=minimum according to model
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Level down: y=channels: 0=subs, 1=fronts, 2=center, 3=surrounds, 4=backs, 5=LFE, 6=Heights1, 7=Heights2. y=dB step: 0 to 10, m=minimum according to model"
    """The description of the packet type, as a string."""

    short_name: str = "LDN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "channel_level_down"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _channel_group_converter = audio_channel_group_field_converter
    """Field converter for channel_group"""

    channel_group: AudioChannelGroup
    """channels: 0=subs, 1=fronts, 2=center, 3=surrounds, 4=backs, 5=LFE, 6=Heights1, 7=Heights2"""

    _step_db_converter = IntFieldConverter(min_length=1, max_length=2, min_value=0, max_value=10, require_sign=False)
    """Field converter for step_db"""

    step_db: int
    """downward dB step: 0 to 10"""

    def __init__(
            self,
            channel_group: AudioChannelGroup,
            step_db: int,
          ):
        super().__init__()
        self.channel_group = channel_group
        self.step_db = step_db

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.channel_group = self._channel_group_converter.from_jsonable(data['channel_group'])
        self.step_db = self._step_db_converter.from_jsonable(data['step_db'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.channel_group, raw_data = self._channel_group_converter.parse_raw_data(raw_data)
        self.step_db, raw_data = self._step_db_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['channel_group'] = self._channel_group_converter.to_jsonable(self.channel_group)
        data['step_db'] = self._step_db_converter.to_jsonable(self.step_db)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._channel_group_converter.to_raw_data(self.channel_group)
        raw_data += self._step_db_converter.to_raw_data(self.step_db)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktChannelLevelUp(WrappedRawPacket):
    """
    Wrapped packet channel_level_up (LUP)

    Level up: y=channels: 0=subs, 1=fronts, 2=center, 3=surrounds, 4=backs, 5=LFE, 6=Heights1, 7=Heights2.  z=dB step: 0 to 10, m=minimum according to model
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Level up: y=channels: 0=subs, 1=fronts, 2=center, 3=surrounds, 4=backs, 5=LFE, 6=Heights1, 7=Heights2.  z=dB step: 0 to 10, m=minimum according to model"
    """The description of the packet type, as a string."""

    short_name: str = "LUP"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "channel_level_up"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _channel_group_converter = audio_channel_group_field_converter
    """Field converter for channel_group"""

    channel_group: AudioChannelGroup
    """channels: 0=subs, 1=fronts, 2=center, 3=surrounds, 4=backs, 5=LFE, 6=Heights1, 7=Heights2"""

    _step_db_converter = IntFieldConverter(min_length=1, max_length=2, min_value=0, max_value=10, require_sign=False)
    """Field converter for step_db"""

    step_db: int
    """upward dB step: 0 to 10"""

    def __init__(
            self,
            channel_group: AudioChannelGroup,
            step_db: int,
          ):
        super().__init__()
        self.channel_group = channel_group
        self.step_db = step_db

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.channel_group = self._channel_group_converter.from_jsonable(data['channel_group'])
        self.step_db = self._step_db_converter.from_jsonable(data['step_db'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.channel_group, raw_data = self._channel_group_converter.parse_raw_data(raw_data)
        self.step_db, raw_data = self._step_db_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['channel_group'] = self._channel_group_converter.to_jsonable(self.channel_group)
        data['step_db'] = self._step_db_converter.to_jsonable(self.step_db)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._channel_group_converter.to_raw_data(self.channel_group)
        raw_data += self._step_db_converter.to_raw_data(self.step_db)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktDeviceBuildDate(WrappedRawPacket):
    """
    Wrapped packet device_build_date (IDB)

    Query software build date. returns IDB followed by software build date e.g. "IDBJun 15 2020"
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query software build date. returns IDB followed by software build date e.g. "IDBJun 15 2020""
    """The description of the packet type, as a string."""

    short_name: str = "IDB"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "device_build_date"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _build_date_converter = StrFieldConverter(min_length=11, max_length=11, blank_pad=False, null_pad=False, rstrip=True, null_strip=True)
    """Field converter for build_date"""

    build_date: Optional[str] = None
    """software build date e.g. "Jun 15 2020""""

    def __init__(
            self,
            build_date: Optional[str]=None,
          ):
        super().__init__()
        self.build_date = build_date

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.build_date = self._build_date_converter.from_jsonable(data.get('build_date', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.build_date, raw_data = self._build_date_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.build_date is not None:
            data['build_date'] = self._build_date_converter.to_jsonable(self.build_date)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._build_date_converter.to_raw_data(self.build_date) if self.build_date is not None else b""
        return raw_data

@register_packet_class
class ApktDeviceFirmwareVersion(WrappedRawPacket):
    """
    Wrapped packet device_firmware_version (IDS)

    Query software version. returns IDS followed by software version e.g. "IDS0.9.5"
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query software version. returns IDS followed by software version e.g. "IDS0.9.5""
    """The description of the packet type, as a string."""

    short_name: str = "IDS"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "device_firmware_version"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _version_converter = StrFieldConverter(min_length=5, max_length=20, blank_pad=False, null_pad=False, rstrip=True, null_strip=True)
    """Field converter for version"""

    version: Optional[str] = None
    """Software version e.g. "0.9.5""""

    def __init__(
            self,
            version: Optional[str]=None,
          ):
        super().__init__()
        self.version = version

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.version = self._version_converter.from_jsonable(data.get('version', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.version, raw_data = self._version_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.version is not None:
            data['version'] = self._version_converter.to_jsonable(self.version)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._version_converter.to_raw_data(self.version) if self.version is not None else b""
        return raw_data

@register_packet_class
class ApktDeviceHardwareVersion(WrappedRawPacket):
    """
    Wrapped packet device_hardware_version (IDH)

    Query hardware version. returns IDH followed by hardware version e.g. "IDH1"
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query hardware version. returns IDH followed by hardware version e.g. "IDH1""
    """The description of the packet type, as a string."""

    short_name: str = "IDH"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "device_hardware_version"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _hardware_version_converter = IntFieldConverter(min_length=1, max_length=3, min_value=1, max_value=100, require_sign=False)
    """Field converter for hardware_version"""

    hardware_version: Optional[int] = None
    """hardware version e.g. 1"""

    def __init__(
            self,
            hardware_version: Optional[int]=None,
          ):
        super().__init__()
        self.hardware_version = hardware_version

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.hardware_version = self._hardware_version_converter.from_jsonable(data.get('hardware_version', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.hardware_version, raw_data = self._hardware_version_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.hardware_version is not None:
            data['hardware_version'] = self._hardware_version_converter.to_jsonable(self.hardware_version)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._hardware_version_converter.to_raw_data(self.hardware_version) if self.hardware_version is not None else b""
        return raw_data

@register_packet_class
class ApktDeviceInfo(WrappedRawPacket):
    """
    Wrapped packet device_info (IDQ)

    Query model and firmware version. returns IDQ followed by model, software version, region, software build date e.g. "IDQAVM 60 US 0.9.5Jun 15 2020"
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query model and firmware version. returns IDQ followed by model, software version, region, software build date e.g. "IDQAVM 60 US 0.9.5Jun 15 2020""
    """The description of the packet type, as a string."""

    short_name: str = "IDQ"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "device_info"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _info_str_converter = StrFieldConverter(min_length=1, max_length=100, blank_pad=False, null_pad=False, rstrip=True, null_strip=True)
    """Field converter for info_str"""

    info_str: Optional[str] = None
    """model, software version, region, software build date e.g. "AVM 60 US 0.9.5Jun 15 2020""""

    def __init__(
            self,
            info_str: Optional[str]=None,
          ):
        super().__init__()
        self.info_str = info_str

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.info_str = self._info_str_converter.from_jsonable(data.get('info_str', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.info_str, raw_data = self._info_str_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.info_str is not None:
            data['info_str'] = self._info_str_converter.to_jsonable(self.info_str)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._info_str_converter.to_raw_data(self.info_str) if self.info_str is not None else b""
        return raw_data

@register_packet_class
class ApktDeviceMacAddress(WrappedRawPacket):
    """
    Wrapped packet device_mac_address (IDN)

    Query MCU MAC Address. returns IDN followed by the unit's unique address e.g. "IDN7CB77B014FE5"
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query MCU MAC Address. returns IDN followed by the unit's unique address e.g. "IDN7CB77B014FE5""
    """The description of the packet type, as a string."""

    short_name: str = "IDN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "device_mac_address"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _id_converter = StrFieldConverter(min_length=12, max_length=12, blank_pad=False, null_pad=False, rstrip=True, null_strip=True)
    """Field converter for id"""

    id: Optional[str] = None
    """Unit's unique MAC address without colons; e.g., "7CB77B014FE5""""

    def __init__(
            self,
            id: Optional[str]=None,
          ):
        super().__init__()
        self.id = id

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.id = self._id_converter.from_jsonable(data.get('id', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.id, raw_data = self._id_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.id is not None:
            data['id'] = self._id_converter.to_jsonable(self.id)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._id_converter.to_raw_data(self.id) if self.id is not None else b""
        return raw_data

@register_packet_class
class ApktDeviceModel(WrappedRawPacket):
    """
    Wrapped packet device_model (IDM)

    Query model. returns IDM followed by model e.g. "IDMAVM 60"
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query model. returns IDM followed by model e.g. "IDMAVM 60""
    """The description of the packet type, as a string."""

    short_name: str = "IDM"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "device_model"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _model_name_converter = StrFieldConverter(min_length=3, max_length=100, blank_pad=False, null_pad=False, rstrip=True, null_strip=True)
    """Field converter for model_name"""

    model_name: Optional[str] = None
    """model e.g. "AVM 60""""

    def __init__(
            self,
            model_name: Optional[str]=None,
          ):
        super().__init__()
        self.model_name = model_name

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.model_name = self._model_name_converter.from_jsonable(data.get('model_name', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.model_name, raw_data = self._model_name_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.model_name is not None:
            data['model_name'] = self._model_name_converter.to_jsonable(self.model_name)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._model_name_converter.to_raw_data(self.model_name) if self.model_name is not None else b""
        return raw_data

@register_packet_class
class ApktDeviceRegion(WrappedRawPacket):
    """
    Wrapped packet device_region (IDR)

    Query region. returns IDR followed by region e.g. "IDRUS "
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query region. returns IDR followed by region e.g. "IDRUS ""
    """The description of the packet type, as a string."""

    short_name: str = "IDR"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "device_region"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _region_converter = StrFieldConverter(min_length=3, max_length=20, blank_pad=True, null_pad=False, rstrip=True, null_strip=True)
    """Field converter for region"""

    region: Optional[str] = None
    """Region, e.g. "US """"

    def __init__(
            self,
            region: Optional[str]=None,
          ):
        super().__init__()
        self.region = region

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.region = self._region_converter.from_jsonable(data.get('region', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.region, raw_data = self._region_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.region is not None:
            data['region'] = self._region_converter.to_jsonable(self.region)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._region_converter.to_raw_data(self.region) if self.region is not None else b""
        return raw_data

@register_packet_class
class ApktDolbyDigitalDialogNormalization(WrappedRawPacket):
    """
    Wrapped packet dolby_digital_dialog_normalization (DIA)

    Query Dolby Digital dialog normalization. returns DIAx where x is dB of normalization, n=not applicable
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query Dolby Digital dialog normalization. returns DIAx where x is dB of normalization, n=not applicable"
    """The description of the packet type, as a string."""

    short_name: str = "DIA"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "dolby_digital_dialog_normalization"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _normalization_db_converter = IntFieldConverter(min_length=1, max_length=2, min_value=0, max_value=99, require_sign=False)
    """Field converter for normalization_db"""

    normalization_db: Optional[int] = None
    """dB of normalization (0-99)"""

    def __init__(
            self,
            normalization_db: Optional[int]=None,
          ):
        super().__init__()
        self.normalization_db = normalization_db

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.normalization_db = self._normalization_db_converter.from_jsonable(data.get('normalization_db', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.normalization_db, raw_data = self._normalization_db_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.normalization_db is not None:
            data['normalization_db'] = self._normalization_db_converter.to_jsonable(self.normalization_db)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._normalization_db_converter.to_raw_data(self.normalization_db) if self.normalization_db is not None else b""
        return raw_data

@register_packet_class
class ApktDolbyDynamicRange(WrappedRawPacket):
    """
    Wrapped packet dolby_dynamic_range (DYN)

    Dolby Digital Dynamic Range (Dolby Digital 5.1 source): 0=Normal, 1=Reduced, 2=Late Night, n=cycle to next
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Dolby Digital Dynamic Range (Dolby Digital 5.1 source): 0=Normal, 1=Reduced, 2=Late Night, n=cycle to next"
    """The description of the packet type, as a string."""

    short_name: str = "DYN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "dolby_dynamic_range"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _dynamic_range_converter = dolby_dynamic_range_field_converter
    """Field converter for dynamic_range"""

    dynamic_range: Optional[DolbyDynamicRange] = None
    """0=Normal, 1=Reduced, 2=Late Night, n=cycle to next"""

    def __init__(
            self,
            dynamic_range: Optional[DolbyDynamicRange]=None,
          ):
        super().__init__()
        self.dynamic_range = dynamic_range

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.dynamic_range = self._dynamic_range_converter.from_jsonable(data.get('dynamic_range', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.dynamic_range, raw_data = self._dynamic_range_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.dynamic_range is not None:
            data['dynamic_range'] = self._dynamic_range_converter.to_jsonable(self.dynamic_range)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._dynamic_range_converter.to_raw_data(self.dynamic_range) if self.dynamic_range is not None else b""
        return raw_data

@register_packet_class
class ApktDolbyPliixMusicCenterWidth(WrappedRawPacket):
    """
    Wrapped packet dolby_pliix_music_center_width (WST)

    Dolby PLIIx Music center width setting: y=0-7.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Dolby PLIIx Music center width setting: y=0-7.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only"
    """The description of the packet type, as a string."""

    short_name: str = "WST"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "dolby_pliix_music_center_width"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _width_converter = IntFieldConverter(min_length=1, max_length=1, min_value=0, max_value=7, require_sign=False)
    """Field converter for width"""

    width: Optional[int] = None
    """Dolby PLIIx Music center width setting (0-7)"""

    def __init__(
            self,
            width: Optional[int]=None,
          ):
        super().__init__()
        self.width = width

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.width = self._width_converter.from_jsonable(data.get('width', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.width, raw_data = self._width_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.width is not None:
            data['width'] = self._width_converter.to_jsonable(self.width)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._width_converter.to_raw_data(self.width) if self.width is not None else b""
        return raw_data

@register_packet_class
class ApktDolbyPliixMusicCenterWidthDown(WrappedRawPacket):
    """
    Wrapped packet dolby_pliix_music_center_width_down (WCD)

    Dolby PLIIx Music center width down.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Dolby PLIIx Music center width down.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only"
    """The description of the packet type, as a string."""

    short_name: str = "WCD"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "dolby_pliix_music_center_width_down"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    def __init__(
            self,
          ):
        super().__init__()

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktDolbyPliixMusicCenterWidthUp(WrappedRawPacket):
    """
    Wrapped packet dolby_pliix_music_center_width_up (WCU)

    Dolby PLIIx Music center width up.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Dolby PLIIx Music center width up.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only"
    """The description of the packet type, as a string."""

    short_name: str = "WCU"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "dolby_pliix_music_center_width_up"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    def __init__(
            self,
          ):
        super().__init__()

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktDolbyPliixMusicDimension(WrappedRawPacket):
    """
    Wrapped packet dolby_pliix_music_dimension (DST)

    Dolby PLIIx Music Dimension setting: y=0-6.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Dolby PLIIx Music Dimension setting: y=0-6.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only"
    """The description of the packet type, as a string."""

    short_name: str = "DST"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "dolby_pliix_music_dimension"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _dimension_converter = IntFieldConverter(min_length=1, max_length=1, min_value=0, max_value=6, require_sign=False)
    """Field converter for dimension"""

    dimension: Optional[int] = None
    """Dolby PLIIx Music Dimension setting (0-6)"""

    def __init__(
            self,
            dimension: Optional[int]=None,
          ):
        super().__init__()
        self.dimension = dimension

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.dimension = self._dimension_converter.from_jsonable(data.get('dimension', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.dimension, raw_data = self._dimension_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.dimension is not None:
            data['dimension'] = self._dimension_converter.to_jsonable(self.dimension)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._dimension_converter.to_raw_data(self.dimension) if self.dimension is not None else b""
        return raw_data

@register_packet_class
class ApktDolbyPliixMusicDimensionDown(WrappedRawPacket):
    """
    Wrapped packet dolby_pliix_music_dimension_down (DID)

    Dolby PLIIx Music Dimension down.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Dolby PLIIx Music Dimension down.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only"
    """The description of the packet type, as a string."""

    short_name: str = "DID"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "dolby_pliix_music_dimension_down"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    def __init__(
            self,
          ):
        super().__init__()

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktDolbyPliixMusicDimensionUp(WrappedRawPacket):
    """
    Wrapped packet dolby_pliix_music_dimension_up (DIU)

    Dolby PLIIx Music Dimension up.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Dolby PLIIx Music Dimension up.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only"
    """The description of the packet type, as a string."""

    short_name: str = "DIU"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "dolby_pliix_music_dimension_up"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    def __init__(
            self,
          ):
        super().__init__()

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktDolbyPliixMusicPanorama(WrappedRawPacket):
    """
    Wrapped packet dolby_pliix_music_panorama (PST)

    Dolby PLIIx Music Panorama. y=0 off, y=1 on.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Dolby PLIIx Music Panorama. y=0 off, y=1 on.  Applicable only when PLIIx Music is selected for 2-channel source. MRX 520 only"
    """The description of the packet type, as a string."""

    short_name: str = "PST"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "dolby_pliix_music_panorama"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _enable_converter = bool_field_converter
    """Field converter for enable"""

    enable: Optional[bool] = None
    """"""

    def __init__(
            self,
            enable: Optional[bool]=None,
          ):
        super().__init__()
        self.enable = enable

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.enable = self._enable_converter.from_jsonable(data.get('enable', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.enable, raw_data = self._enable_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.enable is not None:
            data['enable'] = self._enable_converter.to_jsonable(self.enable)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._enable_converter.to_raw_data(self.enable) if self.enable is not None else b""
        return raw_data

@register_packet_class
class ApktDolbyVolumeEnable(WrappedRawPacket):
    """
    Wrapped packet dolby_volume_enable (SDVS)

    Set Dolby Volume off (y=0) or on (y=1) for the Input # xx (xx=00-ZZ where ZZ is the number of active input configurations, 00=the current input).
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Set Dolby Volume off (y=0) or on (y=1) for the Input # xx (xx=00-ZZ where ZZ is the number of active input configurations, 00=the current input)."
    """The description of the packet type, as a string."""

    short_name: str = "SDVS"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "dolby_volume_enable"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _input_num_converter = IntFieldConverter(min_length=2, max_length=2, min_value=0, max_value=99, require_sign=False)
    """Field converter for input_num"""

    input_num: int
    """"""

    # ============================================================
    # Post-query parameters

    _enable_converter = bool_field_converter
    """Field converter for enable"""

    enable: Optional[bool] = None
    """Dolby Volume off (y=0) or on (y=1)"""

    def __init__(
            self,
            input_num: int,
            enable: Optional[bool]=None,
          ):
        super().__init__()
        self.input_num = input_num
        self.enable = enable

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.input_num = self._input_num_converter.from_jsonable(data['input_num'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.enable = self._enable_converter.from_jsonable(data.get('enable', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.input_num, raw_data = self._input_num_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.enable, raw_data = self._enable_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['input_num'] = self._input_num_converter.to_jsonable(self.input_num)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.enable is not None:
            data['enable'] = self._enable_converter.to_jsonable(self.enable)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._input_num_converter.to_raw_data(self.input_num)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._enable_converter.to_raw_data(self.enable) if self.enable is not None else b""
        return raw_data

@register_packet_class
class ApktDolbyVolumeLevel(WrappedRawPacket):
    """
    Wrapped packet dolby_volume_level (SDVL)

    Set Dolby Volume Leveler to y (0=off, 1-9) for the Input # xx (xx=00-ZZ where ZZ is the number of active input configurations, 00=the current input).
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Set Dolby Volume Leveler to y (0=off, 1-9) for the Input # xx (xx=00-ZZ where ZZ is the number of active input configurations, 00=the current input)."
    """The description of the packet type, as a string."""

    short_name: str = "SDVL"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "dolby_volume_level"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _input_num_converter = IntFieldConverter(min_length=2, max_length=2, min_value=0, max_value=0, require_sign=False)
    """Field converter for input_num"""

    input_num: int
    """Input number (xx=00-ZZ where ZZ is the number of active input configurations, 00=the current input)"""

    # ============================================================
    # Post-query parameters

    _level_converter = IntFieldConverter(min_length=1, max_length=1, min_value=0, max_value=9, require_sign=False)
    """Field converter for level"""

    level: Optional[int] = None
    """Dolby volume level (0=off, 1-9)"""

    def __init__(
            self,
            input_num: int,
            level: Optional[int]=None,
          ):
        super().__init__()
        self.input_num = input_num
        self.level = level

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.input_num = self._input_num_converter.from_jsonable(data['input_num'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.level = self._level_converter.from_jsonable(data.get('level', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.input_num, raw_data = self._input_num_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.level, raw_data = self._level_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['input_num'] = self._input_num_converter.to_jsonable(self.input_num)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.level is not None:
            data['level'] = self._level_converter.to_jsonable(self.level)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._input_num_converter.to_raw_data(self.input_num)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._level_converter.to_raw_data(self.level) if self.level is not None else b""
        return raw_data

@register_packet_class
class ApktFrontPanelBrightness(WrappedRawPacket):
    """
    Wrapped packet front_panel_brightness (FPB)

    Front panel brightness: 0=off, 1=low, 2=medium, 3=high, n=cycle to next
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Front panel brightness: 0=off, 1=low, 2=medium, 3=high, n=cycle to next"
    """The description of the packet type, as a string."""

    short_name: str = "FPB"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "front_panel_brightness"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _brightness_converter = front_panel_brightness_field_converter
    """Field converter for brightness"""

    brightness: Optional[FrontPanelBrightness] = None
    """0=off, 1=low, 2=medium, 3=high, n=cycle to next"""

    def __init__(
            self,
            brightness: Optional[FrontPanelBrightness]=None,
          ):
        super().__init__()
        self.brightness = brightness

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.brightness = self._brightness_converter.from_jsonable(data.get('brightness', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.brightness, raw_data = self._brightness_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.brightness is not None:
            data['brightness'] = self._brightness_converter.to_jsonable(self.brightness)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._brightness_converter.to_raw_data(self.brightness) if self.brightness is not None else b""
        return raw_data

@register_packet_class
class ApktHorizontalVideoResolution(WrappedRawPacket):
    """
    Wrapped packet horizontal_video_resolution (IRH)

    Query active horizontal video resolution (in pixels). return Z1IRHxxxx
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query active horizontal video resolution (in pixels). return Z1IRHxxxx"
    """The description of the packet type, as a string."""

    short_name: str = "IRH"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "horizontal_video_resolution"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _pixels_converter = IntFieldConverter(min_length=1, max_length=4, min_value=0, max_value=9999, require_sign=False)
    """Field converter for pixels"""

    pixels: Optional[int] = None
    """Horizontal resolution in pixels"""

    def __init__(
            self,
            pixels: Optional[int]=None,
          ):
        super().__init__()
        self.pixels = pixels

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.pixels = self._pixels_converter.from_jsonable(data.get('pixels', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.pixels, raw_data = self._pixels_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.pixels is not None:
            data['pixels'] = self._pixels_converter.to_jsonable(self.pixels)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._pixels_converter.to_raw_data(self.pixels) if self.pixels is not None else b""
        return raw_data

@register_packet_class
class ApktInputLongName(WrappedRawPacket):
    """
    Wrapped packet input_long_name (ILN)

    Query the long input name of the input yy=01-ZZ.. returns 'ILNyyzzzz' where 'zzzz'= Input name as set in the setup menu. Maximum length of the long input name is 16 ASCII characters (not applicable to MRX x10).
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query the long input name of the input yy=01-ZZ.. returns 'ILNyyzzzz' where 'zzzz'= Input name as set in the setup menu. Maximum length of the long input name is 16 ASCII characters (not applicable to MRX x10)."
    """The description of the packet type, as a string."""

    short_name: str = "ILN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "input_long_name"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _input_num_converter = IntFieldConverter(min_length=2, max_length=2, min_value=1, max_value=20, require_sign=False)
    """Field converter for input_num"""

    input_num: int
    """input # yy=01-ZZ, where ZZ is number of supported input configurations"""

    # ============================================================
    # Post-query parameters

    _long_name_converter = StrFieldConverter(min_length=1, max_length=16, blank_pad=False, null_pad=False, rstrip=True, null_strip=True)
    """Field converter for long_name"""

    long_name: Optional[str] = None
    """Long input name"""

    def __init__(
            self,
            input_num: int,
            long_name: Optional[str]=None,
          ):
        super().__init__()
        self.input_num = input_num
        self.long_name = long_name

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.input_num = self._input_num_converter.from_jsonable(data['input_num'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.long_name = self._long_name_converter.from_jsonable(data.get('long_name', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.input_num, raw_data = self._input_num_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.long_name, raw_data = self._long_name_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['input_num'] = self._input_num_converter.to_jsonable(self.input_num)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.long_name is not None:
            data['long_name'] = self._long_name_converter.to_jsonable(self.long_name)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._input_num_converter.to_raw_data(self.input_num)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._long_name_converter.to_raw_data(self.long_name) if self.long_name is not None else b""
        return raw_data

@register_packet_class
class ApktInputSelect(WrappedRawPacket):
    """
    Wrapped packet input_select (INP)

    Input Select: yy=01-ZZ. Where ZZ is the number of active input configurations for the specified zone. Eg: 'Z1INP9' would select the 9th input in the main zone. When selecting an input that has no input connector assigned to Z2 the MRX x10 will silently ignore the input select command.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Input Select: yy=01-ZZ. Where ZZ is the number of active input configurations for the specified zone. Eg: 'Z1INP9' would select the 9th input in the main zone. When selecting an input that has no input connector assigned to Z2 the MRX x10 will silently ignore the input select command."
    """The description of the packet type, as a string."""

    short_name: str = "INP"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "input_select"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _input_num_converter = IntFieldConverter(min_length=2, max_length=2, min_value=1, max_value=20, require_sign=False)
    """Field converter for input_num"""

    input_num: Optional[int] = None
    """Input selection 01-ZZ, where ZZ is the number of active input configurations"""

    def __init__(
            self,
            input_num: Optional[int]=None,
          ):
        super().__init__()
        self.input_num = input_num

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.input_num = self._input_num_converter.from_jsonable(data.get('input_num', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.input_num, raw_data = self._input_num_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.input_num is not None:
            data['input_num'] = self._input_num_converter.to_jsonable(self.input_num)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._input_num_converter.to_raw_data(self.input_num) if self.input_num is not None else b""
        return raw_data

@register_packet_class
class ApktInputShortName(WrappedRawPacket):
    """
    Wrapped packet input_short_name (ISN)

    Query the short input name of the input yy=01-ZZ.. returns 'ISNyyzzzz' where 'zzzz'= Input name as set in the setup menu. Maximum length of the short input name is 8 ASCII characters.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query the short input name of the input yy=01-ZZ.. returns 'ISNyyzzzz' where 'zzzz'= Input name as set in the setup menu. Maximum length of the short input name is 8 ASCII characters."
    """The description of the packet type, as a string."""

    short_name: str = "ISN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "input_short_name"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _input_num_converter = IntFieldConverter(min_length=2, max_length=2, min_value=1, max_value=20, require_sign=False)
    """Field converter for input_num"""

    input_num: int
    """input # yy=01-ZZ, where ZZ is number of supported input configurations"""

    # ============================================================
    # Post-query parameters

    _short_name_converter = StrFieldConverter(min_length=1, max_length=8, blank_pad=False, null_pad=False, rstrip=True, null_strip=True)
    """Field converter for short_name"""

    short_name: Optional[str] = None
    """Short input name"""

    def __init__(
            self,
            input_num: int,
            short_name: Optional[str]=None,
          ):
        super().__init__()
        self.input_num = input_num
        self.short_name = short_name

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.input_num = self._input_num_converter.from_jsonable(data['input_num'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.short_name = self._short_name_converter.from_jsonable(data.get('short_name', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.input_num, raw_data = self._input_num_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.short_name, raw_data = self._short_name_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['input_num'] = self._input_num_converter.to_jsonable(self.input_num)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.short_name is not None:
            data['short_name'] = self._short_name_converter.to_jsonable(self.short_name)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._input_num_converter.to_raw_data(self.input_num)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._short_name_converter.to_raw_data(self.short_name) if self.short_name is not None else b""
        return raw_data

@register_packet_class
class ApktIrCommand(WrappedRawPacket):
    """
    Wrapped packet ir_command (SIM)

    Simulated IR Command values for ZxSIMyyyy (use 0 to fill in blanks Ex: Key 1 = 0001)
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Simulated IR Command values for ZxSIMyyyy (use 0 to fill in blanks Ex: Key 1 = 0001)"
    """The description of the packet type, as a string."""

    short_name: str = "SIM"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "ir_command"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _ir_code_converter = ir_code_field_converter
    """Field converter for ir_code"""

    ir_code: IRCode
    """IR code (0000-9999)"""

    def __init__(
            self,
            ir_code: IRCode,
          ):
        super().__init__()
        self.ir_code = ir_code

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.ir_code = self._ir_code_converter.from_jsonable(data['ir_code'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.ir_code, raw_data = self._ir_code_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['ir_code'] = self._ir_code_converter.to_jsonable(self.ir_code)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._ir_code_converter.to_raw_data(self.ir_code)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktLipSyncDelay(WrappedRawPacket):
    """
    Wrapped packet lip_sync_delay (SLIP)

    Set Lip Sync to yyy (0-150) ms for the Input # xx (xx=00-ZZ where ZZ is the number of active input configurations, 00=the current input).  Step must be in increments of 5ms or error will result.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Set Lip Sync to yyy (0-150) ms for the Input # xx (xx=00-ZZ where ZZ is the number of active input configurations, 00=the current input).  Step must be in increments of 5ms or error will result."
    """The description of the packet type, as a string."""

    short_name: str = "SLIP"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "lip_sync_delay"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _input_num_converter = IntFieldConverter(min_length=2, max_length=2, min_value=0, max_value=0, require_sign=False)
    """Field converter for input_num"""

    input_num: int
    """Input number (xx=00-ZZ where ZZ is the number of active input configurations, 00=the current input)"""

    # ============================================================
    # Post-query parameters

    _delay_ms_converter = IntFieldConverter(min_length=3, max_length=3, min_value=0, max_value=150, require_sign=False)
    """Field converter for delay_ms"""

    delay_ms: Optional[int] = None
    """Lip sync delay (0-150) ms; Must be in increments of 5ms"""

    def __init__(
            self,
            input_num: int,
            delay_ms: Optional[int]=None,
          ):
        super().__init__()
        self.input_num = input_num
        self.delay_ms = delay_ms

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.input_num = self._input_num_converter.from_jsonable(data['input_num'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.delay_ms = self._delay_ms_converter.from_jsonable(data.get('delay_ms', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.input_num, raw_data = self._input_num_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.delay_ms, raw_data = self._delay_ms_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['input_num'] = self._input_num_converter.to_jsonable(self.input_num)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.delay_ms is not None:
            data['delay_ms'] = self._delay_ms_converter.to_jsonable(self.delay_ms)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._input_num_converter.to_raw_data(self.input_num)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._delay_ms_converter.to_raw_data(self.delay_ms) if self.delay_ms is not None else b""
        return raw_data

@register_packet_class
class ApktMute(WrappedRawPacket):
    """
    Wrapped packet mute (MUT)

    Mute: 0=unmute, 1=mute, t=toggle
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Mute: 0=unmute, 1=mute, t=toggle"
    """The description of the packet type, as a string."""

    short_name: str = "MUT"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "mute"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _enable_converter = on_off_toggle_field_converter
    """Field converter for enable"""

    enable: Optional[OnOffToggle] = None
    """0=unmute, 1=mute, t=toggle"""

    def __init__(
            self,
            enable: Optional[OnOffToggle]=None,
          ):
        super().__init__()
        self.enable = enable

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.enable = self._enable_converter.from_jsonable(data.get('enable', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.enable, raw_data = self._enable_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.enable is not None:
            data['enable'] = self._enable_converter.to_jsonable(self.enable)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._enable_converter.to_raw_data(self.enable) if self.enable is not None else b""
        return raw_data

@register_packet_class
class ApktNumInputConfigurations(WrappedRawPacket):
    """
    Wrapped packet num_input_configurations (ICN)

    Query number of active input configurations that the system supports. returns ICNyy e.g. "ICN9" for a system with 9 active inputs
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query number of active input configurations that the system supports. returns ICNyy e.g. "ICN9" for a system with 9 active inputs"
    """The description of the packet type, as a string."""

    short_name: str = "ICN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "num_input_configurations"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _num_inputs_converter = bool_field_converter
    """Field converter for num_inputs"""

    num_inputs: Optional[bool] = None
    """number of active input configurations that the system supports"""

    def __init__(
            self,
            num_inputs: Optional[bool]=None,
          ):
        super().__init__()
        self.num_inputs = num_inputs

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.num_inputs = self._num_inputs_converter.from_jsonable(data.get('num_inputs', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.num_inputs, raw_data = self._num_inputs_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.num_inputs is not None:
            data['num_inputs'] = self._num_inputs_converter.to_jsonable(self.num_inputs)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._num_inputs_converter.to_raw_data(self.num_inputs) if self.num_inputs is not None else b""
        return raw_data

@register_packet_class
class ApktOnScreenMessage(WrappedRawPacket):
    """
    Wrapped packet on_screen_message (MSG)

    Display custom on-screen status message for duration of display timeout: x=row 0-1, yyyy=message (number of characters and rows available depends on model)
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Display custom on-screen status message for duration of display timeout: x=row 0-1, yyyy=message (number of characters and rows available depends on model)"
    """The description of the packet type, as a string."""

    short_name: str = "MSG"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "on_screen_message"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _row_converter = IntFieldConverter(min_length=1, max_length=1, min_value=0, max_value=1, require_sign=False)
    """Field converter for row"""

    row: int
    """Row (0-1)"""

    _message_converter = StrFieldConverter(min_length=1, max_length=64, blank_pad=False, null_pad=False, rstrip=True, null_strip=True)
    """Field converter for message"""

    message: str
    """Message to display"""

    def __init__(
            self,
            row: int,
            message: str,
          ):
        super().__init__()
        self.row = row
        self.message = message

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.row = self._row_converter.from_jsonable(data['row'])
        self.message = self._message_converter.from_jsonable(data['message'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.row, raw_data = self._row_converter.parse_raw_data(raw_data)
        self.message, raw_data = self._message_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['row'] = self._row_converter.to_jsonable(self.row)
        data['message'] = self._message_converter.to_jsonable(self.message)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._row_converter.to_raw_data(self.row)
        raw_data += self._message_converter.to_raw_data(self.message)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktPower(WrappedRawPacket):
    """
    Wrapped packet power (POW)

    Power. x=zone: 0 (all), 1 (main), 2 (where applicable), 3 (where applicable).  y: 0=off, 1=on.  When unit is in ECO standby mode (see product manual), it may be necessary to send the power-on command twice. Ex:"Z0POW1;Z0POW1;". The first instance is the wake-up from low-power state. Note that Zx=Z0 applies only to power command.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Power. x=zone: 0 (all), 1 (main), 2 (where applicable), 3 (where applicable).  y: 0=off, 1=on.  When unit is in ECO standby mode (see product manual), it may be necessary to send the power-on command twice. Ex:"Z0POW1;Z0POW1;". The first instance is the wake-up from low-power state. Note that Zx=Z0 applies only to power command."
    """The description of the packet type, as a string."""

    short_name: str = "POW"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "power"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _enable_converter = bool_field_converter
    """Field converter for enable"""

    enable: Optional[bool] = None
    """Power off (y=0) or on (y=1)"""

    def __init__(
            self,
            enable: Optional[bool]=None,
          ):
        super().__init__()
        self.enable = enable

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.enable = self._enable_converter.from_jsonable(data.get('enable', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.enable, raw_data = self._enable_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.enable is not None:
            data['enable'] = self._enable_converter.to_jsonable(self.enable)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._enable_converter.to_raw_data(self.enable) if self.enable is not None else b""
        return raw_data

@register_packet_class
class ApktReportEnable(WrappedRawPacket):
    """
    Wrapped packet report_enable (ECH)

    Tx status set. x=0 off, x=1 on (report running changes to any settings marked as Report)
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Tx status set. x=0 off, x=1 on (report running changes to any settings marked as Report)"
    """The description of the packet type, as a string."""

    short_name: str = "ECH"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "report_enable"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _enable_converter = bool_field_converter
    """Field converter for enable"""

    enable: Optional[bool] = None
    """0=off, 1=on"""

    def __init__(
            self,
            enable: Optional[bool]=None,
          ):
        super().__init__()
        self.enable = enable

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.enable = self._enable_converter.from_jsonable(data.get('enable', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.enable, raw_data = self._enable_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.enable is not None:
            data['enable'] = self._enable_converter.to_jsonable(self.enable)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._enable_converter.to_raw_data(self.enable) if self.enable is not None else b""
        return raw_data

@register_packet_class
class ApktSetupMenuDisplay(WrappedRawPacket):
    """
    Wrapped packet setup_menu_display (SMD)

    Setup menu display: 0=close, 1=open, t=toggle
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Setup menu display: 0=close, 1=open, t=toggle"
    """The description of the packet type, as a string."""

    short_name: str = "SMD"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "setup_menu_display"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _enable_converter = on_off_toggle_field_converter
    """Field converter for enable"""

    enable: Optional[OnOffToggle] = None
    """0=close menu, 1=open menu, t=toggle menu"""

    def __init__(
            self,
            enable: Optional[OnOffToggle]=None,
          ):
        super().__init__()
        self.enable = enable

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.enable = self._enable_converter.from_jsonable(data.get('enable', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.enable, raw_data = self._enable_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.enable is not None:
            data['enable'] = self._enable_converter.to_jsonable(self.enable)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._enable_converter.to_raw_data(self.enable) if self.enable is not None else b""
        return raw_data

@register_packet_class
class ApktSpeakerProfile(WrappedRawPacket):
    """
    Wrapped packet speaker_profile (SSP)

    Set Speaker Profile to # y for profile 1 (y=1), profile 2 (y=2), profile 3 (y=3) and profile 4 (y=4) for the Input # xx (xx=00-ZZ where ZZ is the number of active input configurations, 00= the current input).
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Set Speaker Profile to # y for profile 1 (y=1), profile 2 (y=2), profile 3 (y=3) and profile 4 (y=4) for the Input # xx (xx=00-ZZ where ZZ is the number of active input configurations, 00= the current input)."
    """The description of the packet type, as a string."""

    short_name: str = "SSP"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "speaker_profile"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _input_num_converter = IntFieldConverter(min_length=2, max_length=2, min_value=0, max_value=0, require_sign=False)
    """Field converter for input_num"""

    input_num: int
    """Input number (xx=00-ZZ where ZZ is the number of active input configurations, 00=the current input)"""

    # ============================================================
    # Post-query parameters

    _profile_num_converter = IntFieldConverter(min_length=1, max_length=1, min_value=1, max_value=4, require_sign=False)
    """Field converter for profile_num"""

    profile_num: Optional[int] = None
    """Speaker profile number (1-4)"""

    def __init__(
            self,
            input_num: int,
            profile_num: Optional[int]=None,
          ):
        super().__init__()
        self.input_num = input_num
        self.profile_num = profile_num

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.input_num = self._input_num_converter.from_jsonable(data['input_num'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.profile_num = self._profile_num_converter.from_jsonable(data.get('profile_num', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.input_num, raw_data = self._input_num_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.profile_num, raw_data = self._profile_num_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['input_num'] = self._input_num_converter.to_jsonable(self.input_num)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.profile_num is not None:
            data['profile_num'] = self._profile_num_converter.to_jsonable(self.profile_num)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._input_num_converter.to_raw_data(self.input_num)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._profile_num_converter.to_raw_data(self.profile_num) if self.profile_num is not None else b""
        return raw_data

@register_packet_class
class ApktSpeakerProfileName(WrappedRawPacket):
    """
    Wrapped packet speaker_profile_name (SPN)

    Query the Speaker Profile name of the specified profile # y for profile 1 (y=1), profile 2 (y=2), profile 3 (y=3) and profile 4 (y=4). SPNy? Returns SNPyzzzzzzzz where zzzzzzzz= Profile Name in ASCII as set in the setup menu
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query the Speaker Profile name of the specified profile # y for profile 1 (y=1), profile 2 (y=2), profile 3 (y=3) and profile 4 (y=4). SPNy? Returns SNPyzzzzzzzz where zzzzzzzz= Profile Name in ASCII as set in the setup menu"
    """The description of the packet type, as a string."""

    short_name: str = "SPN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "speaker_profile_name"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _profile_num_converter = IntFieldConverter(min_length=1, max_length=1, min_value=1, max_value=4, require_sign=False)
    """Field converter for profile_num"""

    profile_num: int
    """Speaker profile number (1-4)"""

    # ============================================================
    # Post-query parameters

    _profile_name_converter = StrFieldConverter(min_length=8, max_length=8, blank_pad=True, null_pad=False, rstrip=True, null_strip=True)
    """Field converter for profile_name"""

    profile_name: Optional[str] = None
    """Speaker profile name"""

    def __init__(
            self,
            profile_num: int,
            profile_name: Optional[str]=None,
          ):
        super().__init__()
        self.profile_num = profile_num
        self.profile_name = profile_name

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.profile_num = self._profile_num_converter.from_jsonable(data['profile_num'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.profile_name = self._profile_name_converter.from_jsonable(data.get('profile_name', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.profile_num, raw_data = self._profile_num_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.profile_name, raw_data = self._profile_name_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['profile_num'] = self._profile_num_converter.to_jsonable(self.profile_num)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.profile_name is not None:
            data['profile_name'] = self._profile_name_converter.to_jsonable(self.profile_name)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._profile_num_converter.to_raw_data(self.profile_num)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._profile_name_converter.to_raw_data(self.profile_name) if self.profile_name is not None else b""
        return raw_data

@register_packet_class
class ApktStandbyIpControlEnable(WrappedRawPacket):
    """
    Wrapped packet standby_ip_control_enable (SIP)

    Set Standby IP Control to Disabled (x=0) or Enabled (x=1). This must be enabled for the power-on command to operate via IP. With serial control, the power-on command need not be sent twice (once for wake-up) when this setting is enabled. Note that sending SIP1 disables ECO mode.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Set Standby IP Control to Disabled (x=0) or Enabled (x=1). This must be enabled for the power-on command to operate via IP. With serial control, the power-on command need not be sent twice (once for wake-up) when this setting is enabled. Note that sending SIP1 disables ECO mode."
    """The description of the packet type, as a string."""

    short_name: str = "SIP"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "standby_ip_control_enable"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _enable_converter = bool_field_converter
    """Field converter for enable"""

    enable: Optional[bool] = None
    """Standby IP Control Disabled (x=0) or Enabled (x=1)"""

    def __init__(
            self,
            enable: Optional[bool]=None,
          ):
        super().__init__()
        self.enable = enable

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.enable = self._enable_converter.from_jsonable(data.get('enable', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.enable, raw_data = self._enable_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.enable is not None:
            data['enable'] = self._enable_converter.to_jsonable(self.enable)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._enable_converter.to_raw_data(self.enable) if self.enable is not None else b""
        return raw_data

@register_packet_class
class ApktTone(WrappedRawPacket):
    """
    Wrapped packet tone (TON)

    Tone setting: y=0 bass, 1 treble.  s=sign: +/-, zz=value.  Example: Z1TON0-01 represents a bass cut by 1 dB.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Tone setting: y=0 bass, 1 treble.  s=sign: +/-, zz=value.  Example: Z1TON0-01 represents a bass cut by 1 dB."
    """The description of the packet type, as a string."""

    short_name: str = "TON"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tone"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _eq_band_converter = eq_band_field_converter
    """Field converter for eq_band"""

    eq_band: EqBand
    """0 bass, 1 treble"""

    # ============================================================
    # Post-query parameters

    _level_db_converter = IntFieldConverter(min_length=1, max_length=3, min_value=-10, max_value=10, require_sign=False)
    """Field converter for level_db"""

    level_db: Optional[int] = None
    """Tone adjustment value in dB"""

    def __init__(
            self,
            eq_band: EqBand,
            level_db: Optional[int]=None,
          ):
        super().__init__()
        self.eq_band = eq_band
        self.level_db = level_db

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.eq_band = self._eq_band_converter.from_jsonable(data['eq_band'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.level_db = self._level_db_converter.from_jsonable(data.get('level_db', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.eq_band, raw_data = self._eq_band_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.level_db, raw_data = self._level_db_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['eq_band'] = self._eq_band_converter.to_jsonable(self.eq_band)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.level_db is not None:
            data['level_db'] = self._level_db_converter.to_jsonable(self.level_db)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._eq_band_converter.to_raw_data(self.eq_band)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._level_db_converter.to_raw_data(self.level_db) if self.level_db is not None else b""
        return raw_data

@register_packet_class
class ApktToneDown(WrappedRawPacket):
    """
    Wrapped packet tone_down (TDN)

    Tone down: y=0 bass, 1 treble, zz=dB step: 0 to 10, m=minimum according to model.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Tone down: y=0 bass, 1 treble, zz=dB step: 0 to 10, m=minimum according to model."
    """The description of the packet type, as a string."""

    short_name: str = "TDN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tone_down"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _eq_band_converter = eq_band_field_converter
    """Field converter for eq_band"""

    eq_band: EqBand
    """0 bass, 1 treble"""

    _step_db_converter = IntFieldConverter(min_length=1, max_length=2, min_value=0, max_value=10, require_sign=False)
    """Field converter for step_db"""

    step_db: int
    """downward dB step: 0 to 10"""

    def __init__(
            self,
            eq_band: EqBand,
            step_db: int,
          ):
        super().__init__()
        self.eq_band = eq_band
        self.step_db = step_db

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.eq_band = self._eq_band_converter.from_jsonable(data['eq_band'])
        self.step_db = self._step_db_converter.from_jsonable(data['step_db'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.eq_band, raw_data = self._eq_band_converter.parse_raw_data(raw_data)
        self.step_db, raw_data = self._step_db_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['eq_band'] = self._eq_band_converter.to_jsonable(self.eq_band)
        data['step_db'] = self._step_db_converter.to_jsonable(self.step_db)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._eq_band_converter.to_raw_data(self.eq_band)
        raw_data += self._step_db_converter.to_raw_data(self.step_db)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktToneUp(WrappedRawPacket):
    """
    Wrapped packet tone_up (TUP)

    Tone up: y=0 bass, 1 treble, zz=dB step: 0 to 10, m=minimum according to model.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Tone up: y=0 bass, 1 treble, zz=dB step: 0 to 10, m=minimum according to model."
    """The description of the packet type, as a string."""

    short_name: str = "TUP"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tone_up"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _eq_band_converter = eq_band_field_converter
    """Field converter for eq_band"""

    eq_band: EqBand
    """0 bass, 1 treble"""

    _step_db_converter = IntFieldConverter(min_length=1, max_length=2, min_value=0, max_value=10, require_sign=False)
    """Field converter for step_db"""

    step_db: int
    """upward dB step: 0 to 10"""

    def __init__(
            self,
            eq_band: EqBand,
            step_db: int,
          ):
        super().__init__()
        self.eq_band = eq_band
        self.step_db = step_db

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.eq_band = self._eq_band_converter.from_jsonable(data['eq_band'])
        self.step_db = self._step_db_converter.from_jsonable(data['step_db'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.eq_band, raw_data = self._eq_band_converter.parse_raw_data(raw_data)
        self.step_db, raw_data = self._step_db_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['eq_band'] = self._eq_band_converter.to_jsonable(self.eq_band)
        data['step_db'] = self._step_db_converter.to_jsonable(self.step_db)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._eq_band_converter.to_raw_data(self.eq_band)
        raw_data += self._step_db_converter.to_raw_data(self.step_db)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktTriggerControl(WrappedRawPacket):
    """
    Wrapped packet trigger_control (CTL)

    Trigger control. x=trigger # 0=trigger 1, 1=trigger 2, y=0 menu control, y=1 RS-232/IP
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Trigger control. x=trigger # 0=trigger 1, 1=trigger 2, y=0 menu control, y=1 RS-232/IP"
    """The description of the packet type, as a string."""

    short_name: str = "CTL"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "trigger_control"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = True
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _trigger_control_source_converter = trigger_control_source_field_converter
    """Field converter for trigger_control_source"""

    trigger_control_source: Optional[TriggerControlSource] = None
    """y=0 menu control, y=1 RS-232/IP"""

    def __init__(
            self,
            trigger_control_source: Optional[TriggerControlSource]=None,
          ):
        super().__init__()
        self.trigger_control_source = trigger_control_source

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.trigger_control_source = self._trigger_control_source_converter.from_jsonable(data.get('trigger_control_source', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.trigger_control_source, raw_data = self._trigger_control_source_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.trigger_control_source is not None:
            data['trigger_control_source'] = self._trigger_control_source_converter.to_jsonable(self.trigger_control_source)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._trigger_control_source_converter.to_raw_data(self.trigger_control_source) if self.trigger_control_source is not None else b""
        return raw_data

@register_packet_class
class ApktTriggerSetting(WrappedRawPacket):
    """
    Wrapped packet trigger_setting (SET)

    Trigger set: x: 0=trigger 1, 1=trigger 2.  y: 0=off, 1=on. Only available if trigger control has been set to RS-232/IP for the specified trigger
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Trigger set: x: 0=trigger 1, 1=trigger 2.  y: 0=off, 1=on. Only available if trigger control has been set to RS-232/IP for the specified trigger"
    """The description of the packet type, as a string."""

    short_name: str = "SET"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "trigger_setting"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = True
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _enable_converter = bool_field_converter
    """Field converter for enable"""

    enable: Optional[bool] = None
    """trigger setting: 0=off, 1=on"""

    def __init__(
            self,
            enable: Optional[bool]=None,
          ):
        super().__init__()
        self.enable = enable

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.enable = self._enable_converter.from_jsonable(data.get('enable', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.enable, raw_data = self._enable_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.enable is not None:
            data['enable'] = self._enable_converter.to_jsonable(self.enable)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._enable_converter.to_raw_data(self.enable) if self.enable is not None else b""
        return raw_data

@register_packet_class
class ApktTunerFrequency(WrappedRawPacket):
    """
    Wrapped packet tuner_frequency (FMS)

    Tuner FM setting: 87.50-108.00. Picks nearest valid frequency.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Tuner FM setting: 87.50-108.00. Picks nearest valid frequency."
    """The description of the packet type, as a string."""

    short_name: str = "FMS"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tuner_frequency"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = True
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _frequency_mhz_converter = FloatFieldConverter(min_length=2, max_length=6, min_value=87.5, max_value=108.0, require_sign=False, digs_after_decimal=2)
    """Field converter for frequency_mhz"""

    frequency_mhz: Optional[float] = None
    """"""

    def __init__(
            self,
            frequency_mhz: Optional[float]=None,
          ):
        super().__init__()
        self.frequency_mhz = frequency_mhz

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.frequency_mhz = self._frequency_mhz_converter.from_jsonable(data.get('frequency_mhz', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.frequency_mhz, raw_data = self._frequency_mhz_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.frequency_mhz is not None:
            data['frequency_mhz'] = self._frequency_mhz_converter.to_jsonable(self.frequency_mhz)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._frequency_mhz_converter.to_raw_data(self.frequency_mhz) if self.frequency_mhz is not None else b""
        return raw_data

@register_packet_class
class ApktTunerPresetAssignment(WrappedRawPacket):
    """
    Wrapped packet tuner_preset_assignment (PSA)

    Assign the current station to preset xx (01-30)
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Assign the current station to preset xx (01-30)"
    """The description of the packet type, as a string."""

    short_name: str = "PSA"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tuner_preset_assignment"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = True
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _preset_num_converter = IntFieldConverter(min_length=1, max_length=2, min_value=1, max_value=30, require_sign=False)
    """Field converter for preset_num"""

    preset_num: Optional[int] = None
    """Preset number (01-30)"""

    def __init__(
            self,
            preset_num: Optional[int]=None,
          ):
        super().__init__()
        self.preset_num = preset_num

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.preset_num = self._preset_num_converter.from_jsonable(data.get('preset_num', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.preset_num, raw_data = self._preset_num_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.preset_num is not None:
            data['preset_num'] = self._preset_num_converter.to_jsonable(self.preset_num)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._preset_num_converter.to_raw_data(self.preset_num) if self.preset_num is not None else b""
        return raw_data

@register_packet_class
class ApktTunerPresetNext(WrappedRawPacket):
    """
    Wrapped packet tuner_preset_next (PUP)

    Select the next available preset
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Select the next available preset"
    """The description of the packet type, as a string."""

    short_name: str = "PUP"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tuner_preset_next"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = True
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    def __init__(
            self,
          ):
        super().__init__()

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktTunerPresetPrevious(WrappedRawPacket):
    """
    Wrapped packet tuner_preset_previous (PDN)

    Select the previous available preset
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Select the previous available preset"
    """The description of the packet type, as a string."""

    short_name: str = "PDN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tuner_preset_previous"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = True
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    def __init__(
            self,
          ):
        super().__init__()

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktTunerPresetRemove(WrappedRawPacket):
    """
    Wrapped packet tuner_preset_remove (PRM)

    Remove the preset xx. xx=00-30. 00=current station is removed from all presets
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Remove the preset xx. xx=00-30. 00=current station is removed from all presets"
    """The description of the packet type, as a string."""

    short_name: str = "PRM"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tuner_preset_remove"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = True
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _preset_num_converter = IntFieldConverter(min_length=1, max_length=2, min_value=1, max_value=30, require_sign=False)
    """Field converter for preset_num"""

    preset_num: int
    """Preset number (01-30)"""

    def __init__(
            self,
            preset_num: int,
          ):
        super().__init__()
        self.preset_num = preset_num

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.preset_num = self._preset_num_converter.from_jsonable(data['preset_num'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.preset_num, raw_data = self._preset_num_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['preset_num'] = self._preset_num_converter.to_jsonable(self.preset_num)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._preset_num_converter.to_raw_data(self.preset_num)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktTunerPresetSelect(WrappedRawPacket):
    """
    Wrapped packet tuner_preset_select (PSL)

    Tuner preset xx select (xx=01-30)
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Tuner preset xx select (xx=01-30)"
    """The description of the packet type, as a string."""

    short_name: str = "PSL"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tuner_preset_select"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = True
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _preset_num_converter = IntFieldConverter(min_length=1, max_length=2, min_value=1, max_value=30, require_sign=False)
    """Field converter for preset_num"""

    preset_num: int
    """Preset number (01-30)"""

    def __init__(
            self,
            preset_num: int,
          ):
        super().__init__()
        self.preset_num = preset_num

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.preset_num = self._preset_num_converter.from_jsonable(data['preset_num'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.preset_num, raw_data = self._preset_num_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['preset_num'] = self._preset_num_converter.to_jsonable(self.preset_num)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._preset_num_converter.to_raw_data(self.preset_num)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktTunerSeekDown(WrappedRawPacket):
    """
    Wrapped packet tuner_seek_down (KDN)

    Seek down
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Seek down"
    """The description of the packet type, as a string."""

    short_name: str = "KDN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tuner_seek_down"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = True
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    def __init__(
            self,
          ):
        super().__init__()

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktTunerSeekUp(WrappedRawPacket):
    """
    Wrapped packet tuner_seek_up (KUP)

    Seek up
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Seek up"
    """The description of the packet type, as a string."""

    short_name: str = "KUP"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tuner_seek_up"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = True
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    def __init__(
            self,
          ):
        super().__init__()

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktTunerTuneDown(WrappedRawPacket):
    """
    Wrapped packet tuner_tune_down (TDN)

    Tune down
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Tune down"
    """The description of the packet type, as a string."""

    short_name: str = "TDN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tuner_tune_down"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = True
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    def __init__(
            self,
          ):
        super().__init__()

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktTunerTuneUp(WrappedRawPacket):
    """
    Wrapped packet tuner_tune_up (TUP)

    Tune up
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Tune up"
    """The description of the packet type, as a string."""

    short_name: str = "TUP"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "tuner_tune_up"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = False
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = True
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    def __init__(
            self,
          ):
        super().__init__()

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktVerticalVideoResolution(WrappedRawPacket):
    """
    Wrapped packet vertical_video_resolution (IRV)

    Query active vertical video resolution (in pixels/lines). return Z1IRVxxxx
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query active vertical video resolution (in pixels/lines). return Z1IRVxxxx"
    """The description of the packet type, as a string."""

    short_name: str = "IRV"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "vertical_video_resolution"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _pixels_converter = IntFieldConverter(min_length=1, max_length=4, min_value=0, max_value=9999, require_sign=False)
    """Field converter for pixels"""

    pixels: Optional[int] = None
    """Vertical resolution in pixels"""

    def __init__(
            self,
            pixels: Optional[int]=None,
          ):
        super().__init__()
        self.pixels = pixels

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.pixels = self._pixels_converter.from_jsonable(data.get('pixels', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.pixels, raw_data = self._pixels_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.pixels is not None:
            data['pixels'] = self._pixels_converter.to_jsonable(self.pixels)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._pixels_converter.to_raw_data(self.pixels) if self.pixels is not None else b""
        return raw_data

@register_packet_class
class ApktVideoInputResolution(WrappedRawPacket):
    """
    Wrapped packet video_input_resolution (VIR)

    Query video input resolution: 0=no input, 1=other, 2=1080p60, 3=1080p50, 4=1080p24, 5=1080i60, 6=1080i50, 7=720p60, 8=720p50, 9=576p50, 10=576i50, 11=480p60, 12=480i60, 13=3D, 14=4k. returns Z1VIRxx
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query video input resolution: 0=no input, 1=other, 2=1080p60, 3=1080p50, 4=1080p24, 5=1080i60, 6=1080i50, 7=720p60, 8=720p50, 9=576p50, 10=576i50, 11=480p60, 12=480i60, 13=3D, 14=4k. returns Z1VIRxx"
    """The description of the packet type, as a string."""

    short_name: str = "VIR"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "video_input_resolution"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _resolution_converter = video_resolution_field_converter
    """Field converter for resolution"""

    resolution: Optional[VideoResolution] = None
    """resolution: 0=no input, 1=other, 2=1080p60, 3=1080p50, 4=1080p24, 5=1080i60, 6=1080i50, 7=720p60, 8=720p50, 9=576p50, 10=576i50, 11=480p60, 12=480i60, 13=3D, 14=4k"""

    def __init__(
            self,
            resolution: Optional[VideoResolution]=None,
          ):
        super().__init__()
        self.resolution = resolution

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.resolution = self._resolution_converter.from_jsonable(data.get('resolution', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.resolution, raw_data = self._resolution_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.resolution is not None:
            data['resolution'] = self._resolution_converter.to_jsonable(self.resolution)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._resolution_converter.to_raw_data(self.resolution) if self.resolution is not None else b""
        return raw_data

@register_packet_class
class ApktVolumeDown(WrappedRawPacket):
    """
    Wrapped packet volume_down (VDN)

    Volume down: y=dB step: 0 to 10, m=minimum according to model. Entry is rounded to nearest valid value.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Volume down: y=dB step: 0 to 10, m=minimum according to model. Entry is rounded to nearest valid value."
    """The description of the packet type, as a string."""

    short_name: str = "VDN"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "volume_down"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _step_db_converter = IntFieldConverter(min_length=1, max_length=2, min_value=0, max_value=10, require_sign=False)
    """Field converter for step_db"""

    step_db: int
    """Number of dB to decrease volume by (0-10)"""

    def __init__(
            self,
            step_db: int,
          ):
        super().__init__()
        self.step_db = step_db

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.step_db = self._step_db_converter.from_jsonable(data['step_db'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.step_db, raw_data = self._step_db_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['step_db'] = self._step_db_converter.to_jsonable(self.step_db)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._step_db_converter.to_raw_data(self.step_db)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktVolumeLevel(WrappedRawPacket):
    """
    Wrapped packet volume_level (VOL)

    Volume setting: s=sign: +/-, yy=value.  Example: Z1VOL-35 represents main zone volume set to -35 dB.  Entry is rounded to nearest valid value.
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Volume setting: s=sign: +/-, yy=value.  Example: Z1VOL-35 represents main zone volume set to -35 dB.  Entry is rounded to nearest valid value."
    """The description of the packet type, as a string."""

    short_name: str = "VOL"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "volume_level"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = True
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _level_db_converter = IntFieldConverter(min_length=1, max_length=3, min_value=-99, max_value=99, require_sign=False)
    """Field converter for level_db"""

    level_db: Optional[int] = None
    """Volume level in db, -99 to +99"""

    def __init__(
            self,
            level_db: Optional[int]=None,
          ):
        super().__init__()
        self.level_db = level_db

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.level_db = self._level_db_converter.from_jsonable(data.get('level_db', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.level_db, raw_data = self._level_db_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.level_db is not None:
            data['level_db'] = self._level_db_converter.to_jsonable(self.level_db)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._level_db_converter.to_raw_data(self.level_db) if self.level_db is not None else b""
        return raw_data

@register_packet_class
class ApktVolumeUp(WrappedRawPacket):
    """
    Wrapped packet volume_up (VUP)

    Volume up: y=dB step: 0 to 10, m=minimum according to model. Entry is rounded to nearest valid value
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Volume up: y=dB step: 0 to 10, m=minimum according to model. Entry is rounded to nearest valid value"
    """The description of the packet type, as a string."""

    short_name: str = "VUP"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "volume_up"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = False
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Pre-query parameters

    _step_db_converter = IntFieldConverter(min_length=1, max_length=2, min_value=0, max_value=10, require_sign=False)
    """Field converter for step_db"""

    step_db: int
    """Number of dB to increase volume by (0-10)"""

    def __init__(
            self,
            step_db: int,
          ):
        super().__init__()
        self.step_db = step_db

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        self.step_db = self._step_db_converter.from_jsonable(data['step_db'])

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        self.step_db, raw_data = self._step_db_converter.parse_raw_data(raw_data)
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        data['step_db'] = self._step_db_converter.to_jsonable(self.step_db)

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._step_db_converter.to_raw_data(self.step_db)
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

@register_packet_class
class ApktZoneTunerStatus(WrappedRawPacket):
    """
    Wrapped packet zone_tuner_status (TBS)

    Query tuner status. returns ZxTBSy where x=1 Main Zone x=2 Zone2 y=0 Not on Tuner y=1 Tuner on FM
    """

    # ============================================================
    # Class attributes (common to all instances of the subclass)

    description: str = "Query tuner status. returns ZxTBSy where x=1 Main Zone x=2 Zone2 y=0 Not on Tuner y=1 Tuner on FM"
    """The description of the packet type, as a string."""

    short_name: str = "TBS"
    """The 3-4 character upper-case alhabetic string identifying the packet type, as a string."""

    long_name: str = "zone_tuner_status"
    """The snake-case string identifying the packet type, as a string."""

    requires_zone: bool = True
    """Whether the packet type requires a zone number to be specified."""

    requires_tuner: bool = False
    """Whether the packet type requires a tuner number to be specified."""

    requires_trigger: bool = False
    """Whether the packet type requires a trigger number to be specified."""

    is_queryable: bool = True
    """Whether this packet type is queryable"""

    is_commandable: bool = True
    """Whether this packet type can be sent as a non-query request."""

    is_reportable: bool = False
    """Whether changes to values associated with this packet type are asynchronously
       reported."""

    # ============================================================
    # Post-query parameters

    _tuner_status_converter = tuner_status_field_converter
    """Field converter for tuner_status"""

    tuner_status: Optional[TunerStatus] = None
    """y=0 Not on Tuner, y=1 Tuner on FM"""

    def __init__(
            self,
            tuner_status: Optional[TunerStatus]=None,
          ):
        super().__init__()
        self.tuner_status = tuner_status

    def init_pre_query_from_jsonable(self, data: JsonableDict) -> None:
        return

    def init_post_query_from_jsonable(self, data: JsonableDict) -> None:
        self.tuner_status = self._tuner_status_converter.from_jsonable(data.get('tuner_status', None))

    def parse_pre_query(self, raw_data: bytes) -> bytes:
        return raw_data

    def parse_post_query(self, raw_data: bytes) -> bytes:
        self.tuner_status, raw_data = self._tuner_status_converter.parse_raw_data(raw_data)
        return raw_data

    def pre_query_to_jsonable(self, data: JsonableDict) -> None:
        return

    def post_query_to_jsonable(self, data: JsonableDict) -> None:
        if self.tuner_status is not None:
            data['tuner_status'] = self._tuner_status_converter.to_jsonable(self.tuner_status)

    def pre_query_to_raw_data(self) -> bytes:
        raw_data = b""
        return raw_data

    def post_query_to_raw_data(self) -> bytes:
        raw_data = b""
        raw_data += self._tuner_status_converter.to_raw_data(self.tuner_status) if self.tuner_status is not None else b""
        return raw_data
