# Copyright (c) 2023 Samuel J. McKelvie
#
# MIT License - See LICENSE file accompanying this package.
#

"""
Enum of IR codes for Anthem receivers.

This file is auto-generated by scripts/gen_ir_codes.py. Do not edit.
"""

from __future__ import annotations

from ..internal_types import *
from ..exceptions import AnthemReceiverError

from abc import ABC, abstractmethod
from enum import Enum

_T = TypeVar('_T')

class FieldConverter(Generic[_T], ABC):
    """An interface that can convert a custom field type to and from a JSON-serializable type and a raw data type."""

    @abstractmethod
    def to_jsonable(self, value: _T) -> Jsonable:
        """Converts a field value to a JSON-serializable type."""
        ...

    @abstractmethod
    def from_jsonable(self, data: Jsonable) -> _T:
        """Converts a JSON-serializable type to a field value."""
        ...

    @abstractmethod
    def to_rawdata(self, value: _T) -> bytes:
        """Converts a field value to raw data to be included in an Anthem RawPacket."""
        ...

    @abstractmethod
    def parse_rawdata(self, raw_data: bytes) -> Tuple[_T, bytes]:
        """Parses a field value from raw data in an Anthem RawPacket.

        Returns a tuple of the parsed field value and the remaining raw data.
        """
        ...

class StrFieldConverter(FieldConverter[str]):
    """A FieldConverter for str fields."""

    min_length: int
    """The minimum length of the rawdata field, in bytes."""

    max_length: int
    """The maximum length of the rawdata field, in bytes."""

    blank_pad: bool
    """Whether to pad the rawdata field with spaces to the minimum length."""

    null_pad: bool
    """Whether to pad the rawdata field with nulls to the minimum length."""

    blank_strip: bool
    """Whether to strip trailing spaces from the rawdata field."""

    null_strip: bool
    """Whether to strip trailing nulls from the rawdata field."""

    def __init__(self, min_length: int=1, max_length: int=12, blank_pad: bool=True, null_pad: bool=False, blank_strip: Optional[bool]=None, null_strip: Optional[bool]=None):
        self.min_length = min_length
        self.max_length = max_length
        self.blank_pad = blank_pad
        self.null_pad = null_pad
        self.blank_strip = blank_strip if blank_strip is not None else blank_pad
        self.null_strip = null_strip if null_strip is not None else null_pad
        assert 0 < min_length <= max_length

    def to_jsonable(self, value: str) -> Jsonable:
        """Converts a field value to a JSON-serializable type."""
        if not isinstance(value, str):
            raise TypeError(f"Value {value!r} is not a str")
        return value

    def from_jsonable(self, data: Jsonable) -> str:
        """Converts a JSON-serializable type to a field value."""
        v = str(data)
        return v

    def to_rawdata(self, value: str) -> bytes:
        """Converts a field value to raw data to be included in an Anthem RawPacket."""
        if not isinstance(value, str):
            raise TypeError(f"Value {value!r} is not a str")
        result = value.encode('utf-8')
        while self.blank_pad and len(result) < self.min_length:
            result += b' '
        while self.null_pad and len(result) < self.min_length:
            result += b'\x00'
        if len(result) < self.min_length:
            raise AnthemReceiverError(f"String parameter {value!r} shorter than minimum length {self.min_length}, and padding not allowed")
        if len(result) > self.max_length:
            raise AnthemReceiverError(f"String parameter {value!r} longer than maximum length {self.max_length}")
        return result

    def parse_rawdata(self, raw_data: bytes) -> Tuple[str, bytes]:
        """Parses a field value from raw data in an Anthem RawPacket.

        Returns a tuple of the parsed field value and the remaining raw data.
        """
        plen = min(self.max_length, len(raw_data))
        if plen < self.min_length:
            raise AnthemReceiverError(f"Remaining packet data {self.raw_data!r} shorter than minimum string length {self.min_length}")
        raw_result = raw_data[:plen]
        remaining = raw_data[plen:]
        if self.null_strip:
            while plen > 0 and raw_result[plen-1] == 0:
                plen -= 1
            raw_result = raw_result[:plen]
        result = raw_result.decode('utf-8')
        if self.blank_strip:
            result = result.rstrip()
        return result, remaining

class IntFieldConverter(FieldConverter[int]):
    """A FieldConverter for int fields."""

    min_length: int
    """The minimum length of the rawdata field, in bytes."""

    max_length: int
    """The maximum length of the rawdata field, in bytes."""

    min_value: int
    """The minimum value of the field."""

    max_value: int
    """The maximum value of the field."""

    require_sign: bool
    """True if a +/- sign is required for the field."""

    def __init__(self, min_length: int=1, max_length: int=12, min_value: int=0, max_value: int=0xffffffff, require_sign: bool=False):
        self.min_length = min_length
        self.max_length = max_length
        self.min_value = min_value
        self.max_value = max_value
        self.require_sign = require_sign
        assert 0 < min_length <= max_length
        assert min_value <= max_value

    def to_jsonable(self, value: int) -> Jsonable:
        """Converts a field value to a JSON-serializable type."""
        if not isinstance(value, int):
            raise TypeError(f"Value {value!r} is not an int")
        if not (self.minvalue <= value <= self.maxvalue):
            raise ValueError(f"Value {value!r} is not in range {self.minvalue}..{self.maxvalue}")
        return value

    def from_jsonable(self, data: Jsonable) -> int:
        """Converts a JSON-serializable type to a field value."""
        v = int(data)
        if not (self.minvalue <= v <= self.maxvalue):
            raise ValueError(f"Value {data!r} is not in range {self.minvalue}..{self.maxvalue}")
        return v

    def to_rawdata(self, value: int) -> bytes:
        """Converts a field value to raw data to be included in an Anthem RawPacket."""
        if not isinstance(value, int):
            raise TypeError(f"Value {value!r} is not an int")
        sign = "-" if value < 0 else ("+" if self.require_sign else "")
        abs_vstr = str(abs(value))
        npad = max(0, self.min_length - len(sign) - len(abs_vstr))
        result = sign.encode('utf-8') + b'0' * npad + abs_vstr.encode('utf-8')
        if len(result) > self.max_length:
            raise AnthemReceiverError(f"Integer parameter {result!r} longer than maximum length {self.max_length}")
        return result

    def parse_rawdata(self, raw_data: bytes) -> Tuple[int, bytes]:
        """Parses a field value from raw data in an Anthem RawPacket.

        Returns a tuple of the parsed field value and the remaining raw data.
        """
        plen = min(self.max_length, len(raw_data))
        for i in range(plen):
            if not ((self.allow_sign and i == 0 and raw_data[i] in b'-+') or raw_data[i] in b'0123456789'):
                plen = i
                break
        if plen < self.min_length:
            raise AnthemReceiverError(f"Remaining packet data {self.raw_data!r} shorter than minimum integer length {self.min_length}")
        result = int(raw_data[:plen])
        if result < self.min_value or result > self.max_value:
            raise AnthemReceiverError(f"Remaining packet data {self.raw_data!r} integer value {result} out of range {self.min_value}..{self.max_value}")
        remaining = raw_data[plen:]
        return result, remaining

class FloatFieldConverter(FieldConverter[float]):
    """A FieldConverter for float fields."""

    min_length: int
    """The minimum length of the rawdata field, in bytes."""

    max_length: int
    """The maximum length of the rawdata field, in bytes."""

    min_value: float
    """The minimum value of the field."""

    max_value: float
    """The maximum value of the field."""

    require_sign: bool
    """True if a +/- sign is required for the field."""

    digs_after_decimal: int
    """The number of digits after the decimal point."""

    def __init__(self, min_length: int=1, max_length: int=12, min_value: float=0.0, max_value: float=999999.0, require_sign: bool=False,
               digs_after_decimal: int=0):
        self.min_length = min_length
        self.max_length = max_length
        self.min_value = min_value
        self.max_value = max_value
        self.require_sign = require_sign
        self.digs_after_decimal = digs_after_decimal
        assert 0 < min_length <= max_length
        assert 0 <= max_length - 1 - (1 if require_sign else 0)
        assert min_value <= max_value

    def to_jsonable(self, value: float) -> Jsonable:
        """Converts a field value to a JSON-serializable type."""
        if not isinstance(value, (float, int)):
            raise TypeError(f"Value {value!r} is not an int")
        value = float(value)
        if not (self.minvalue <= value <= self.maxvalue):
            raise ValueError(f"Value {value!r} is not in range {self.minvalue}..{self.maxvalue}")
        return value

    def from_jsonable(self, data: Jsonable) -> float:
        """Converts a JSON-serializable type to a field value."""
        v = float(data)
        if not (self.minvalue <= v <= self.maxvalue):
            raise ValueError(f"Value {data!r} is not in range {self.minvalue}..{self.maxvalue}")
        return v

    def to_rawdata(self, value: float) -> bytes:
        """Converts a field value to raw data to be included in an Anthem RawPacket."""
        if not isinstance(value, float):
            raise TypeError(f"Value {value!r} is not an int")
        sign = "-" if value < 0 else ("+" if self.require_sign else "")
        abs_vstr = f"{abs(value):.{self.digs_after_decimal}f}"
        npad = max(0, self.min_length - len(sign) - len(abs_vstr))
        result = sign.encode('utf-8') + b'0' * npad + abs_vstr.encode('utf-8')
        if len(result) > self.max_length:
            raise AnthemReceiverError(f"Float parameter {result!r} longer than maximum length {self.max_length}")
        return result

    def parse_rawdata(self, raw_data: bytes) -> Tuple[float, bytes]:
        """Parses a field value from raw data in an Anthem RawPacket.

        Returns a tuple of the parsed field value and the remaining raw data.
        """
        plen = min(self.max_length, len(raw_data))
        for i in range(plen):
            if not ((self.require_sign and i == 0 and raw_data[i] in b'-+') or raw_data[i] in b'.0123456789'):
                plen = i
                break
        if plen < self.min_length:
            raise AnthemReceiverError(f"Remaining packet data {self.raw_data!r} shorter than minimum string length {self.min_length}")
        result = float(raw_data[:plen])
        if result < self.min_value or result > self.max_value:
            raise AnthemReceiverError(f"Remaining packet data {self.raw_data!r} float value {result} out of range {self.min_value}..{self.max_value}")
        remaining = raw_data[plen:]
        return result, remaining

_IntEnumT = TypeVar('_IntEnumT', bound=Enum)
class IntEnumFieldConverter(FieldConverter[_IntEnumT]):
    """A FieldConverter for integer enum fields."""

    int_converter: IntFieldConverter

    def __init__(self, min_length: int=1, max_length: int=12, min_value: int=0, max_value: int=0xffffffff, require_sign: bool=False):
        self.int_converter = IntFieldConverter(min_length=min_length, max_length=max_length, min_value=min_value, max_value=max_value, require_sign=require_sign)

    def to_jsonable(self, value: _IntEnumT) -> Jsonable:
        """Converts a field value to a JSON-serializable type."""
        if not isinstance(value, _IntEnumT):
            raise TypeError(f"Value {value!r} is not an of type {_IntEnumT}")
        i_value: int = value.value
        if not isinstance(i_value, int):
            raise TypeError(f"Value {value!r} is not an int enum")
        return self.int_converter.to_jsonable(i_value)

    def from_jsonable(self, data: Jsonable) -> _IntEnumT:
        """Converts a JSON-serializable type to a field value."""
        i_value = self.int_converter.from_jsonable(data)
        value = cast(_IntEnumT, _IntEnumT(i_value))
        return value

    def to_rawdata(self, value: _IntEnumT) -> bytes:
        """Converts a field value to raw data to be included in an Anthem RawPacket."""
        if not isinstance(value, _IntEnumT):
            raise TypeError(f"Value {value!r} is not of type {_IntEnumT}")
        i_value = value.value
        if not isinstance(i_value, int):
            raise TypeError(f"Value {value!r} is not an int enum")
        result = self.int_converter.to_rawdata(i_value)
        return result

    def parse_rawdata(self, raw_data: bytes) -> Tuple[_IntEnumT, bytes]:
        """Parses a field value from raw data in an Anthem RawPacket.

        Returns a tuple of the parsed field value and the remaining raw data.
        """
        i_value, remaining = self.int_converter.parse_rawdata(raw_data)
        result = cast(_IntEnumT, _IntEnumT(i_value))
        return result, remaining

_StrEnumT = TypeVar('_StrEnumT', bound=Enum)
class StrEnumFieldConverter(FieldConverter[_StrEnumT]):
    """A FieldConverter for str enum fields."""

    str_converter: StrFieldConverter

    def __init__(self, min_length: int=1, max_length: int=12):
        self.str_converter = StrFieldConverter(min_length=min_length, max_length=max_length)

    def to_jsonable(self, value: _StrEnumT) -> Jsonable:
        """Converts a field value to a JSON-serializable type."""
        if not isinstance(value, _StrEnumT):
            raise TypeError(f"Value {value!r} is not an of type {_StrEnumT}")
        s_value: str = value.value
        if not isinstance(s_value, str):
            raise TypeError(f"Value {value!r} is not a str enum")
        return self.str_converter.to_jsonable(s_value)

    def from_jsonable(self, data: Jsonable) -> _StrEnumT:
        """Converts a JSON-serializable type to a field value."""
        s_value = self.str_converter.from_jsonable(data)
        value = cast(_StrEnumT, _StrEnumT(s_value))
        return value

    def to_rawdata(self, value: _StrEnumT) -> bytes:
        """Converts a field value to raw data to be included in an Anthem RawPacket."""
        if not isinstance(value, _StrEnumT):
            raise TypeError(f"Value {value!r} is not of type {_StrEnumT}")
        s_value = cast(str, value.value)
        if not isinstance(s_value, str):
            raise TypeError(f"Value {value!r} is not a str enum")
        result = self.str_converter.to_rawdata(s_value)
        return result

    def parse_rawdata(self, raw_data: bytes) -> Tuple[_StrEnumT, bytes]:
        """Parses a field value from raw data in an Anthem RawPacket.

        Returns a tuple of the parsed field value and the remaining raw data.
        """
        s_value, remaining = self.str_converter.parse_rawdata(raw_data)
        result = _StrEnumT(s_value)
        return result, remaining

class ExpandableIntEnumFieldConverter(FieldConverter[Union[int, _IntEnumT]]):
    """A FieldConverter for integer enum fields that can accept integers outside the enum."""

    int_converter: IntFieldConverter

    def __init__(self, min_length: int=1, max_length: int=12, min_value: int=0, max_value: int=0xffffffff, require_sign: bool=False):
        self.int_converter = IntFieldConverter(min_length=min_length, max_length=max_length, min_value=min_value, max_value=max_value, require_sign=require_sign)

    def to_jsonable(self, value: Union[int, _IntEnumT]) -> Jsonable:
        """Converts a field value to a JSON-serializable type."""
        if isinstance(value, _IntEnumT):
            i_value = cast(int, value.value)
        else:
            if not isinstance(value, int):
                raise TypeError(f"Value {value!r} is not an int or of type {_IntEnumT}")
            i_value = value
        if not isinstance(i_value, int):
            raise TypeError(f"Value {value!r} is not an int enum")
        return self.int_converter.to_jsonable(i_value)

    def from_jsonable(self, data: Jsonable) -> Union[int, _IntEnumT]:
        """Converts a JSON-serializable type to a field value."""
        i_value = self.int_converter.from_jsonable(data)
        try:
            value = cast(_IntEnumT, _IntEnumT(i_value))
        except ValueError:
            value = int(i_value)
        return value

    def to_rawdata(self, value: Union[int, _IntEnumT]) -> bytes:
        """Converts a field value to raw data to be included in an Anthem RawPacket."""
        if isinstance(value, _IntEnumT):
            i_value = cast(int, value.value)
        else:
            if not isinstance(value, int):
                raise TypeError(f"Value {value!r} is not an int or of type {_IntEnumT}")
            i_value = value
        if not isinstance(i_value, int):
            raise TypeError(f"Value {value!r} is not an int enum")
        result = self.int_converter.to_rawdata(i_value)
        return result

    def parse_rawdata(self, raw_data: bytes) -> Tuple[Union[int, _IntEnumT], bytes]:
        """Parses a field value from raw data in an Anthem RawPacket.

        Returns a tuple of the parsed field value and the remaining raw data.
        """
        i_value, remaining = self.int_converter.parse_rawdata(raw_data)
        try:
            result = cast(_IntEnumT, _IntEnumT(i_value))
        except ValueError:
            result = i_value
        return result, remaining

_StrEnumT = TypeVar('_StrEnumT', bound=Enum)
class StrEnumFieldConverter(FieldConverter[_StrEnumT]):
    """A FieldConverter for str enum fields."""

    str_converter: StrFieldConverter

    def __init__(self, min_length: int=1, max_length: int=12):
        self.str_converter = StrFieldConverter(min_length=min_length, max_length=max_length)

    def to_jsonable(self, value: _StrEnumT) -> Jsonable:
        """Converts a field value to a JSON-serializable type."""
        if not isinstance(value, _StrEnumT):
            raise TypeError(f"Value {value!r} is not an of type {_StrEnumT}")
        s_value: str = value.value
        if not isinstance(s_value, str):
            raise TypeError(f"Value {value!r} is not a str enum")
        return self.str_converter.to_jsonable(s_value)

    def from_jsonable(self, data: Jsonable) -> _StrEnumT:
        """Converts a JSON-serializable type to a field value."""
        s_value = self.str_converter.from_jsonable(data)
        value = _StrEnumT(s_value)
        return value

    def to_rawdata(self, value: _StrEnumT) -> bytes:
        """Converts a field value to raw data to be included in an Anthem RawPacket."""
        if not isinstance(value, _StrEnumT):
            raise TypeError(f"Value {value!r} is not of type {_StrEnumT}")
        s_value: str = value.value
        if not isinstance(s_value, str):
            raise TypeError(f"Value {value!r} is not a str enum")
        result = self.str_converter.to_rawdata(s_value)
        return result

    def parse_rawdata(self, raw_data: bytes) -> Tuple[_StrEnumT, bytes]:
        """Parses a field value from raw data in an Anthem RawPacket.

        Returns a tuple of the parsed field value and the remaining raw data.
        """
        s_value, remaining = self.str_converter.parse_rawdata(raw_data)
        result = _StrEnumT(s_value)
        return result, remaining

class ExpandableStrEnumFieldConverter(FieldConverter[Union[str, _StrEnumT]]):
    """A FieldConverter for str enum fields that can accept strs outside the enum."""

    str_converter: StrFieldConverter

    def __init__(self, min_length: int=1, max_length: int=12):
        self.str_converter = StrFieldConverter(min_length=min_length, max_length=max_length)

    def to_jsonable(self, value: Union[str, _StrEnumT]) -> Jsonable:
        """Converts a field value to a JSON-serializable type."""
        if isinstance(value, _StrEnumT):
            s_value = cast(str, value.value)
        else:
            if not isinstance(value, int):
                raise TypeError(f"Value {value!r} is not a str or of type {_StrEnumT}")
            s_value = value
        if not isinstance(s_value, str):
            raise TypeError(f"Value {value!r} is not a str enum")
        return self.str_converter.to_jsonable(s_value)

    def from_jsonable(self, data: Jsonable) -> Union[str, _StrEnumT]:
        """Converts a JSON-serializable type to a field value."""
        s_value = self.str_converter.from_jsonable(data)
        try:
            value = cast(_StrEnumT, _StrEnumT(s_value))
        except ValueError:
            value = str(s_value)
        return value

    def to_rawdata(self, value: Union[str, _StrEnumT]) -> bytes:
        """Converts a field value to raw data to be included in an Anthem RawPacket."""
        if isinstance(value, _StrEnumT):
            s_value = cast(str, value.value)
        else:
            if not isinstance(value, str):
                 raise TypeError(f"Value {value!r} is not a str or of type {_StrEnumT}")
            s_value = value
        if not isinstance(s_value, int):
             raise TypeError(f"Value {value!r} is not astr enum")
        result = self.str_converter.to_rawdata(s_value)
        return result

    def parse_rawdata(self, raw_data: bytes) -> Tuple[Union[str, _StrEnumT], bytes]:
        """Parses a field value from raw data in an Anthem RawPacket.

        Returns a tuple of the parsed field value and the remaining raw data.
        """
        s_value, remaining = self.str_converter.parse_rawdata(raw_data)
        try:
            result = cast(_StrEnumT, _StrEnumT(s_value))
        except ValueError:
            result = s_value
        return result, remaining

class BoolFieldConverter(FieldConverter[bool]):
    """A FieldConverter for bool fields."""

    int_converter: IntFieldConverter

    def __init__(self):
        self.int_converter = IntFieldConverter(min_length=1, max_length=1, min_value=0, max_value=1)

    def to_jsonable(self, value: bool) -> Jsonable:
        """Converts a field value to a JSON-serializable type."""
        if not isinstance(value, bool):
            raise TypeError(f"Value {value!r} is not a bool")
        return value

    def from_jsonable(self, data: Jsonable) -> bool:
        """Converts a JSON-serializable type to a field value."""
        if not isinstance(data, bool):
            raise TypeError(f"Value {data!r} is not a bool")
        return data

    def to_rawdata(self, value: bool) -> bytes:
        """Converts a field value to raw data to be included in an Anthem RawPacket."""
        if not isinstance(value, bool):
            raise TypeError(f"Value {value!r} is not a bool")
        return b'1' if value else b'0'

    def parse_rawdata(self, raw_data: bytes) -> Tuple[bool, bytes]:
        """Parses a field value from raw data in an Anthem RawPacket.

        Returns a tuple of the parsed field value and the remaining raw data.
        """
        if len(raw_data) < 1:
            raise AnthemReceiverError(f"Remaining packet data {self.raw_data!r} shorter than minimum boolean length 1")
        b = raw_data[0]
        if not b in b'01':
            raise AnthemReceiverError(f"Packet raw data {self.raw_data!r} next byte not in boolean range b'0'..b'1'")
        result = raw_data[0] == b'1'
        remaining = raw_data[1:]
        return result, remaining

bool_field_converter = BoolFieldConverter()

class FrontPanelBrightness(Enum):
    """Front panel brightness."""
    OFF    = 0
    LOW    = 1
    MEDIUM = 2
    HIGH   = 3
    CYCLE  = 4    # command only; not a state

front_panel_brightness_field_converter: IntEnumFieldConverter[FrontPanelBrightness] = IntEnumFieldConverter(min_length=1, max_length=1, min_value=0, max_value=4)

class OnOffToggle(Enum):
    """Off, on, or toggle."""
    OFF    = "0"
    ON     = "1"
    TOGGLE = "t"    # command only; not a state

on_off_toggle_field_converter: StrEnumFieldConverter[OnOffToggle] = StrEnumFieldConverter(min_length=1, max_length=1)

class AudioChannelGroup(Enum)
    """Audio channel group."""
    SUBS      = 0
    FRONTS    = 1
    CENTER    = 2
    SURROUNDS = 3
    BACKS     = 4
    LFE       = 5
    HEIGHTS1  = 6
    HEIGHTS2  = 7

audio_channel_group_field_converter: IntEnumFieldConverter[AudioChannelGroup] = IntEnumFieldConverter(min_length=1, max_length=1, min_value=0, max_value=7)

class EqBand(Enum):
    """Equalization band (bass or treble)."""
    BASS    = 0
    TREBLE  = 1

eq_band_field_converter: IntEnumFieldConverter[EqBand] = IntEnumFieldConverter(min_length=1, max_length=1, min_value=0, max_value=1)

class TunerStatus(Enum):
    """Tuner status."""
    OFF = 0
    ON_FM = 1

tuner_status_field_converter: IntEnumFieldConverter[TunerStatus] = IntEnumFieldConverter(min_length=1, max_length=1, min_value=0, max_value=1)

class VideoResolution(Enum):
    """Video resolution."""
    NO_INPUT     = 0
    OTHER        = 1
    RES_1080P_60 = 2
    RES_1080P_50 = 3
    RES_1080P_24 = 4
    RES_1080I_60 = 5
    RES_1080I_50 = 6
    RES_720P_60  = 7
    RES_720P_50  = 8
    RES_576P_50  = 9
    RES_576I_50  = 10
    RES_480P_60  = 11
    RES_480I_60  = 12
    RES_3D       = 13
    RES_4K       = 14

video_resolution_field_converter: IntEnumFieldConverter[VideoResolution] = IntEnumFieldConverter(min_length=1, max_length=1, min_value=0, max_value=14)

class AudioChannelsStatus(Enum):
    """Audio channels status."""
    NO_INPUT     = 0
    OTHER        = 1
    MONO         = 2
    STEREO       = 3
    SURROUND_5_1 = 4
    SURROUND_6_1 = 5
    SURROUND_7_1 = 6
    ATMOS        = 7

audio_channels_status_field_converter: IntEnumFieldConverter[AudioChannelsStatus] = IntEnumFieldConverter(min_length=1, max_length=1, min_value=0, max_value=7)

class AudioFormat(Enum):
    """Audio format."""
    NO_INPUT     = 0
    ANALOG       = 1
    PCM          = 2
    DOLBY        = 3
    DSD          = 4
    DTS          = 5
    ATMOS        = 6

audio_format_field_converter: IntEnumFieldConverter[AudioFormat] = IntEnumFieldConverter(min_length=1, max_length=1, min_value=0, max_value=6)

class AudioListeningMode(Enum):
    """Audio listening mode."""
    NONE                   = "00"
    ANTHEM_LOGIC_MOVIE     = "01"
    ANTHEM_LOGIC_MUSIC     = "02"
    PLIIx_MOVIE            = "03"
    PLIIx_MUSIC            = "04"
    NEO_6_CINEMA           = "05"
    NEO_6_MUSIC            = "06"
    ALL_CHANNEL_STEREO     = "07"
    ALL_CHANNEL_MONO       = "08"
    MONO                   = "09"
    MONO_ACADEMY           = "10"
    MONO_L                 = "11"
    MONO_R                 = "12"
    HIGH_BLEND             = "13"
    DOLBY_SURROUND         = "14"
    NEO_X_CINEMA           = "15"
    NEO_X_MUSIC            = "16"
    CYCLE_NEXT             = "na"    # command only; not a state
    CYCLE_PREVIOUS         = "pa"    # command only; not a state

audio_listening_mode_field_converter: StrEnumFieldConverter[AudioListeningMode] = StrEnumFieldConverter(min_length=2, max_length=2)

class DolbyDynamicRange(Enum):
    """Dolby dynamic range."""
    # "0=Normal, 1=Reduced, 2=Late Night, n=cycle to next"
    NORMAL     = "0"
    REDUCED    = "1"
    LATE_NIGHT = "2"
    CYCLE_NEXT = "n"    # command only; not a state

dolby_dynamic_range_field_converter: StrEnumFieldConverter[DolbyDynamicRange] = StrEnumFieldConverter(min_length=1, max_length=1)

class TriggerControlSource(Enum):
    """Trigger control source."""
    MENU = 0
    RS_232 = 1

trigger_control_source_field_converter: IntEnumFieldConverter[TriggerControlSource] = IntEnumFieldConverter(min_length=1, max_length=1, min_value=0, max_value=1)


